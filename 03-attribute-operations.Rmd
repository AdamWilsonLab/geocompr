# Attribute data operations {#attr}

## Prerequisites {-}

- This chapter requires **tidyverse**, **sf**, and **spData** packages:

```{r, message=FALSE}
library(sf)
library(tidyverse)
```

- You must have loaded the `world` and `worldbank_df` data from the spData package:

```{r, results='hide'}
library(spData)
data("world")
data("worldbank_df")
```

## Introduction

Attribute data is non-geographic information associated with geographical data.
In the context of simple features, introduced in the previous chapter, this means a tabular data joined onto the `geometry` variables of `sf` objects.
This structure enables multiple columns to represent a range of attributes for thousands of features (one row per feature).

There is a strong overlap between geographical and non-geographical operations:
non-spatial subset, aggregate and join operations each have their geographical equivalents.
For this reason this chapter provides the foundation for next (chapter \@ref(spatial-data-operations)).
The two chapters share the same structure and input data; it is recommended that they are read together.

The non-spatial versions of these methods are common and easy to understand with R, so they are covered first.
The methods are largely cross-transferable to the trickier tasks of spatial data operations, so pay attention!

Simple features are represented as objects, such as `world`, with class `sf` in the **sf** package:

```{r}
class(world)
```

The output shows that `sf` objects have two classes (`sf` and `data.frame`), meaning that are essentially data frames.
Using data frames, the basic class used for data analysis in R, particularly within the **tidyverse** package ecosystem, has many advantages when it comes to attribute data operations.
It means that all the accumulated know-how in the R community for handling data frames to be applied to geographic data which contain attributes.

This 'world' dataset contains 63 non-geographical variables (and one geometry column) with data for almost 200 countries, as can be ascertained using base functions for working with tabular data:

```{r}
dim(world) # it is a 2 dimensional object, with rows and columns
nrow(world) # how many rows?
ncol(world) # how many columns?
```

Extracting the attribute data of an `sf` object is the same as removing the geometry column:

```{r}
world_df = world
st_geometry(world_df) = NULL
class(world_df)
```

This can be useful if the geometry column causes problem, e.g. by occupying large amounts of RAM.
However, for most cases there is no harm in keeping the geometry column, as data frame operations on `sf` will only act on the attribute data.
For this reason, being good at working with attribute data in geographic data is the same being proficient at handling data frames in R.
For many applications, the most effective and intuitive way to work with data frames is with the **dplyr** package.

## Base vs data.table vs dplyr

Simple feature objects of class `sf` behave exactly the same as `data.frame` objects for most base R operations.
Unlike objects of class `Spatial` defined by the **sp** package, `sf` objects are also compatible with **dplyr** and **data.table** packages.
This is an advantage because they provide fast functions for data manipulation.

Which method you use is largely a matter of preference.
In this chapter the focus is largely on **dplyr** because of it's intuitive function names and its ability to perform multiple chained operations using the pipe operator.
The important thing is that you select a data processing paradigm of choice, and master it.

## Attribute subsetting

```{r, eval=FALSE}
world[1:6, ] # subset rows
```

```{r, eval=FALSE}
world[, 1:3] # subset columns
```

After each operation, the geometry column is preserved.

**dplyr** makes working with data frames easier and is compatible with `sf` objects, after the package has been loaded:

The `select()` function, for example, can be used to both subset and renames columns in a single line, for example:

```{r}
world_orig = world # create copy of world dataset for future reference
world1 = select(world_orig, name_long, continent, population = pop)
head(world1, n = 2)
```

This is more concises than the base R equivalent (which saves the result as an object called `world2` to avoid overriding the `world` dataset created previously):

```{r, eval=FALSE}
world2 = world_orig[c("name_long", "continent", "pop")] # subset columns by name
names(world2)[3] = "population" # rename column manually
```

The *pipe* operator (` %>% `), which passes the output of one function into the first argument of the next function, is commonly used in **dplyr** data analysis workflows.
This works because the fundamental **dplyr** functions (or 'verbs', like `select()`) all take a data frame object in and spit a data frame object out.
Combining many functions together with pipes is called *chaining* or *piping*.
The advantage over base R for complex data processing operations is that this approach prevents nested functions and is easy to read because there is a clear order and modularity to the work (a piped command can be commented out, for example).

The example below shows yet another way of creating the renamed `world` dataset, using the pipe operator:

```{r}
world3 = world_orig %>%
        select(name_long, continent)
```

The pipe operator can be used for many data processing tasks with attribute data:

```{r}
# todo - describe these: ==, !=, >, >=, <, <=, &, |
# Filtering attribute data with dplyr
world_few_rows = world %>% 
        filter(pop > 1e9)

head(world_few_rows)
```

This is equivalent to the following base R code ([note](https://github.com/Robinlovelace/geocompr/issues/28) NAs are forbidden for subsetting):

```{r, eval=FALSE}
# subsetting simple feature rows by values
world$pop[is.na(world$pop)] = 0 
world_few_rows = world[world$pop > 1e9,]
```

## Attribute data aggregation 


```{r, results='hide'}
# data summary (not shown)
summary(world)

# data summary by groups (not shown)
world_continents = world %>% 
        group_by(continent) %>% 
        summarise(continent_pop = sum(pop, na.rm = TRUE), country_n = n())
world_continents
```

```{r}
# sort variables
## by name
world_continents %>% 
        arrange(continent)
## by population (in descending order)
world_continents %>% 
        arrange(-continent_pop)
```

## Attribute data joining 

<!-- - intro - explain why we use joins, what's the syntax, a list of functions -->
<!-- - very small example; x - a polygon map with several areas; y - data.frame - mostly the same keys, one/two different -->
<!-- - each example should have a map, e.g. left_join() on the left, map with colored polygons on the right -->
<!-- - there will (probably) be issues with some of joins - investigate the ideas + github sfr issues -->
<!-- - are all of the joins are suitable for spatial data? (right/full) -->
<!-- - how duplicate keys works with sf -->
<!-- - exercises -->

<!-- data prep -->

```{r, echo=FALSE}
north_america = world %>%
        filter(subregion == "Northern America") %>%
        select(iso_a2, name_long)
# plot(north_america[0])
wb_north_america = worldbank_df %>% 
        filter(name %in% c("Canada", "Mexico", "United States"))
```

<!-- left_join() -->

```{r}
left_join1 <- north_america %>% 
        left_join(., wb_north_america, by = "iso_a2")
left_join1
plot(left_join1["pop_growth"])
```

```{r}
left_join2 <- north_america %>% 
        left_join(., wb_north_america, by = c("name_long" = "name"))
left_join2
```

```{r}
left_join3 <- north_america %>% 
        left_join(., wb_north_america, by = c("iso_a2", "name_long" = "name"))
left_join3
```

<!-- right_join() -->

```{r}
# error
right_join1 <- north_america %>% 
        right_join(., wb_north_america, by = "iso_a2") #%>% plot()
right_join1
```

```{r}
# error
right_join2 <- wb_north_america %>% 
        right_join(., north_america, by = "iso_a2") #%>% plot()
right_join2
```

<!-- inner_join() -->

```{r}
inner_join1 <- north_america %>% 
        inner_join(., wb_north_america, by = "iso_a2") 
inner_join1
plot(inner_join1["pop_growth"])
```

<!-- full_join() -->

```{r}
# error
full_join1 <- north_america %>% 
        full_join(., wb_north_america, by = "iso_a2") #%>% plot()
full_join1
```

<!-- semi_join() -->

```{r}
semi_join1 <- north_america %>% 
        semi_join(., wb_north_america, by = "iso_a2")
semi_join1
```

<!-- anti_join() -->

```{r}
anti_join1 <- north_america %>% 
        anti_join(., wb_north_america, by = "iso_a2")
anti_join1
```

<!-- https://github.com/dgrtwo/fuzzyjoin -->
<!-- http://r4ds.had.co.nz/relational-data.html -->

## Attribute data creation

## Removing spatial information

Most of the function from **sf** package do not drop a `geometry` column. To extract a data frame `st_geometry()` or `st_set_geometry()` function can be used.

```{r}
world_st = world
st_geometry(world_st) = NULL
class(world_st)

# OR

world_st2 = world
world_st2 = world_st2 %>% st_set_geometry(NULL)
class(world_st2)
```


<!-- 
- dplyr, tidyr, and purrr packages
- lubridate??
- pipes
-->

<!-- 
- view, add new rows/columns, subset, select, summarize 
-->
