# Geographical data I/O {#read-write}

<!-- ## Prerequisites {-} -->

<!-- - You must have run the code in Chapter \@ref(intro) -->

<!-- ```{r, echo=FALSE, include=FALSE} -->
<!-- if(!exists("world")) -->
<!--         source("code/01-introduction.R") -->
<!-- ``` -->

<!-- ## Introduction -->

The previous chapters introduced this book and provided an overview of spatial data classes in R, with a focus on simple features.
This chapter is about getting spatial data that is 'out there' onto your computer and then, perhaps after processing it with techniques described in this book, back out to the world.
We include a section (\@ref(visual-outputs)) on visualisation because outputting data in a human (not just computer) readable enables non-programmers to benefit from your work.
If your aim is to use geocomputation to improve the world, e.g. by encouraging evidence-based policies, this final stage is vital.

Data I/O means "reading and writing data".
We use the acronym instead of plain English not only because it's more concise, or to confuse you, but because I/O is the term used by computer scientists.
It is useful to think of data import and export --- or loading and saving, yet another way of saying the same thing --- from a computing perspective.
We will see how concepts such as computational efficiency, hard disk space and 'idempotence' should influence the most effective way or reading and writing your valuable datasets.
<!-- todo: check we mention computational efficiency, disk-space and 'idempotence' -->

## Data import (I)
More precisely, loaded into the workspace o
<!-- coud add a footnot here mentioning `.GlobalEnv` -->

Reading, writing and plotting are 3 of the most important initial stages in geocomputation.
If you cannot load your data, it's not even worth starting.
If you cannot write your processed data, it will make it hard to collaborate with others.
Furthermore, an often-overlooked issue is that if you cannot create visuals of your spatial data, it will be hard to understand.
For this reason this introductory chapter also has a section on basic map making.

Spatial data comes in a wide variety of file formats, and **sf** is adept at handling them, via its interface to GDAL.
A major advantage of **sf** is that it is fast at geographical data I/O, as illustrated in the benchmark below:

```{r, results='hide'}
library(sf)
f = system.file("shapes/wrld.shp", package = "spData")
library(microbenchmark)
bench_read = microbenchmark(times = 5,
        st_read(f),
        rgdal::readOGR(f)
)
```

```{r}
bench_read$time[1] / bench_read$time[2]
```

The results demonstrate that **sf** can be much faster (*`r round(bench_read$time[1] / bench_read$time[2], 0)` times faster* in this case) than **rgdal** at reading-in the world countries shapefile.

The counterpart of `st_read()` is `st_write()`. This allows writing to a range of geographic vector file types, including the common formats `.geojson`, `.shp` and `.gpkg`. `st_read()` will decide which driver to use automatically, based on the file name, as illustrated in the benchmark below demonstrating write speeds for each format.

```{r, echo=FALSE, results='hide'}
world_files = list.files(pattern = "world\\.")
file.remove(world_files)
```

```{r, warning=FALSE}
system.time(st_write(world, "world.geojson", quiet = TRUE))
system.time(st_write(world, "world.shp", quiet = TRUE)) 
system.time(st_write(world, "world.gpkg", quiet = TRUE))
```

The full range of file-types supported by **sf** is reported by `st_drivers()`, the first 2 of which are shown below:

```{r}
sf_drivers = st_drivers()
head(sf_drivers, n = 2)
```

## Data output (O)

## Visual outputs


<!-- ## Vector -->

<!-- 
- sf package 
- st_drivers
- st_read, read_sf
- st_write, write_sf
- text files 
- WKT, WKB, sp (st_as_sf)
-->

<!-- ## Raster -->

<!-- 
- raster package 
- raster
-->
