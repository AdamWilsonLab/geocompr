<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Geocomputation with R</title>
  <meta name="description" content="Forthcoming book on geographical data with R.">
  <meta name="generator" content="bookdown 0.5 and GitBook 2.6.7">

  <meta property="og:title" content="Geocomputation with R" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="http://robinlovelace.net/geocompr" />
  
  <meta property="og:description" content="Forthcoming book on geographical data with R." />
  <meta name="github-repo" content="Robinlovelace/geocompr" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Geocomputation with R" />
  
  <meta name="twitter:description" content="Forthcoming book on geographical data with R." />
  

<meta name="author" content="Robin Lovelace, Jakub Nowosad, Jannes Muenchow">


<meta name="date" content="2017-09-06">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="attr.html">
<link rel="next" href="read-write.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script src="libs/htmlwidgets-0.9/htmlwidgets.js"></script>
<link href="libs/leaflet-0.7.7/leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-0.7.7/leaflet.js"></script>
<link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet" />
<link href="libs/leaflet-label-0.2.2/leaflet.label.css" rel="stylesheet" />
<script src="libs/leaflet-label-0.2.2/leaflet.label.js"></script>
<script src="libs/Proj4Leaflet-0.7.2/proj4-compressed.js"></script>
<script src="libs/Proj4Leaflet-0.7.2/proj4leaflet.js"></script>
<script src="libs/leaflet-binding-1.1.0/leaflet.js"></script>
<script src="libs/leaflet-providers-1.0.27/leaflet-providers.js"></script>
<script src="libs/leaflet-providers-plugin-1.1.0/leaflet-providers-plugin.js"></script>
<link href="libs/leaflet-awesomemarkers-2.0.3/leaflet.awesome-markers.css" rel="stylesheet" />
<script src="libs/leaflet-awesomemarkers-2.0.3/leaflet.awesome-markers.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-99618359-1', 'auto');
  ga('send', 'pageview');

</script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="css/style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Geocomputation with R</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Welcome</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#development"><i class="fa fa-check"></i>Development</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#reproducibility"><i class="fa fa-check"></i>Reproducibility</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#what-is-geocomputation"><i class="fa fa-check"></i><b>1.1</b> What is geocomputation?</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#why-geocomputation-with-r"><i class="fa fa-check"></i><b>1.2</b> Why Geocomputation with R?</a></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#software-for-geocomputation"><i class="fa fa-check"></i><b>1.3</b> Software for geocomputation</a></li>
<li class="chapter" data-level="1.4" data-path="intro.html"><a href="intro.html#rs-spatial-ecosystem"><i class="fa fa-check"></i><b>1.4</b> R’s spatial ecosystem</a></li>
<li class="chapter" data-level="1.5" data-path="intro.html"><a href="intro.html#rs-spatial-history"><i class="fa fa-check"></i><b>1.5</b> R’s spatial history</a></li>
<li class="chapter" data-level="1.6" data-path="intro.html"><a href="intro.html#exercises"><i class="fa fa-check"></i><b>1.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="spatial-class.html"><a href="spatial-class.html"><i class="fa fa-check"></i><b>2</b> Geographic data in R</a><ul>
<li class="chapter" data-level="" data-path="spatial-class.html"><a href="spatial-class.html#prerequisites"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="2.1" data-path="spatial-class.html"><a href="spatial-class.html#vector-data"><i class="fa fa-check"></i><b>2.1</b> Vector data</a><ul>
<li class="chapter" data-level="2.1.1" data-path="spatial-class.html"><a href="spatial-class.html#intro-sf"><i class="fa fa-check"></i><b>2.1.1</b> An introduction to simple features</a></li>
<li class="chapter" data-level="2.1.2" data-path="spatial-class.html"><a href="spatial-class.html#why-simple-features"><i class="fa fa-check"></i><b>2.1.2</b> Why Simple Features?</a></li>
<li class="chapter" data-level="2.1.3" data-path="spatial-class.html"><a href="spatial-class.html#basic-map"><i class="fa fa-check"></i><b>2.1.3</b> Basic map making</a></li>
<li class="chapter" data-level="2.1.4" data-path="spatial-class.html"><a href="spatial-class.html#sf_classes"><i class="fa fa-check"></i><b>2.1.4</b> Simple feature classes</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="spatial-class.html"><a href="spatial-class.html#raster-data"><i class="fa fa-check"></i><b>2.2</b> Raster data</a><ul>
<li class="chapter" data-level="2.2.1" data-path="spatial-class.html"><a href="spatial-class.html#an-introduction-to-raster"><i class="fa fa-check"></i><b>2.2.1</b> An introduction to raster</a></li>
<li class="chapter" data-level="2.2.2" data-path="spatial-class.html"><a href="spatial-class.html#basic-map-making"><i class="fa fa-check"></i><b>2.2.2</b> Basic map making</a></li>
<li class="chapter" data-level="2.2.3" data-path="spatial-class.html"><a href="spatial-class.html#raster-classes"><i class="fa fa-check"></i><b>2.2.3</b> Raster classes</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="spatial-class.html"><a href="spatial-class.html#crs-intro"><i class="fa fa-check"></i><b>2.3</b> Coordinate Reference Systems</a></li>
<li class="chapter" data-level="2.4" data-path="spatial-class.html"><a href="spatial-class.html#units"><i class="fa fa-check"></i><b>2.4</b> Units</a></li>
<li class="chapter" data-level="2.5" data-path="spatial-class.html"><a href="spatial-class.html#exercises-1"><i class="fa fa-check"></i><b>2.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="attr.html"><a href="attr.html"><i class="fa fa-check"></i><b>3</b> Attribute data operations</a><ul>
<li class="chapter" data-level="" data-path="attr.html"><a href="attr.html#prerequisites-1"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="3.1" data-path="attr.html"><a href="attr.html#introduction"><i class="fa fa-check"></i><b>3.1</b> Introduction</a></li>
<li class="chapter" data-level="3.2" data-path="attr.html"><a href="attr.html#vector-attribute-manipulation"><i class="fa fa-check"></i><b>3.2</b> Vector attribute manipulation</a><ul>
<li class="chapter" data-level="3.2.1" data-path="attr.html"><a href="attr.html#vector-attribute-subsetting"><i class="fa fa-check"></i><b>3.2.1</b> Vector attribute subsetting</a></li>
<li class="chapter" data-level="3.2.2" data-path="attr.html"><a href="attr.html#vector-attribute-aggregation"><i class="fa fa-check"></i><b>3.2.2</b> Vector attribute aggregation</a></li>
<li class="chapter" data-level="3.2.3" data-path="attr.html"><a href="attr.html#vector-attribute-joining"><i class="fa fa-check"></i><b>3.2.3</b> Vector attribute joining</a></li>
<li class="chapter" data-level="3.2.4" data-path="attr.html"><a href="attr.html#creating-attributes-and-removing-spatial-information"><i class="fa fa-check"></i><b>3.2.4</b> Creating attributes and removing spatial information</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="attr.html"><a href="attr.html#manipulating-raster-objects"><i class="fa fa-check"></i><b>3.3</b> Manipulating raster objects</a><ul>
<li class="chapter" data-level="3.3.1" data-path="attr.html"><a href="attr.html#raster-subsetting"><i class="fa fa-check"></i><b>3.3.1</b> Raster subsetting</a></li>
<li class="chapter" data-level="3.3.2" data-path="attr.html"><a href="attr.html#summarizing-raster-objects"><i class="fa fa-check"></i><b>3.3.2</b> Summarizing raster objects</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="attr.html"><a href="attr.html#exercises-2"><i class="fa fa-check"></i><b>3.4</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html"><i class="fa fa-check"></i><b>4</b> Spatial data operations</a><ul>
<li class="chapter" data-level="" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#prerequisites-2"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="4.1" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#introduction-1"><i class="fa fa-check"></i><b>4.1</b> Introduction</a></li>
<li class="chapter" data-level="4.2" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-subsetting"><i class="fa fa-check"></i><b>4.2</b> Spatial subsetting</a></li>
<li class="chapter" data-level="4.3" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-joining-and-aggregation"><i class="fa fa-check"></i><b>4.3</b> Spatial joining and aggregation</a><ul>
<li class="chapter" data-level="4.3.1" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-congruence-and-areal-interpolation"><i class="fa fa-check"></i><b>4.3.1</b> Spatial congruence and areal interpolation</a></li>
<li class="chapter" data-level="4.3.2" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#non-overlapping-joins"><i class="fa fa-check"></i><b>4.3.2</b> Non-overlapping joins</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#topological-relations"><i class="fa fa-check"></i><b>4.4</b> Topological relations</a></li>
<li class="chapter" data-level="4.5" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#modifying-geometry-data"><i class="fa fa-check"></i><b>4.5</b> Modifying geometry data</a></li>
<li class="chapter" data-level="4.6" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#distance-relations"><i class="fa fa-check"></i><b>4.6</b> Distance relations</a></li>
<li class="chapter" data-level="4.7" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-operations-on-raster-data"><i class="fa fa-check"></i><b>4.7</b> Spatial operations on raster data</a><ul>
<li class="chapter" data-level="4.7.1" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#map-algebra-local-focal-zonal-global"><i class="fa fa-check"></i><b>4.7.1</b> Map algebra: local, focal, zonal, global</a></li>
<li class="chapter" data-level="4.7.2" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#mosaics"><i class="fa fa-check"></i><b>4.7.2</b> Mosaics</a></li>
<li class="chapter" data-level="4.7.3" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#raster-aggregation-disaggregation-and-resampling"><i class="fa fa-check"></i><b>4.7.3</b> Raster aggregation, disaggregation and resampling</a></li>
<li class="chapter" data-level="4.7.4" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#exercises-3"><i class="fa fa-check"></i><b>4.7.4</b> Exercises</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="read-write.html"><a href="read-write.html"><i class="fa fa-check"></i><b>5</b> Geographic data I/O</a><ul>
<li class="chapter" data-level="5.1" data-path="read-write.html"><a href="read-write.html#data-input-i"><i class="fa fa-check"></i><b>5.1</b> Data Input (I)</a><ul>
<li class="chapter" data-level="5.1.1" data-path="read-write.html"><a href="read-write.html#vector-data-1"><i class="fa fa-check"></i><b>5.1.1</b> Vector data</a></li>
<li class="chapter" data-level="5.1.2" data-path="read-write.html"><a href="read-write.html#raster-data-1"><i class="fa fa-check"></i><b>5.1.2</b> Raster data</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="read-write.html"><a href="read-write.html#data-output-o"><i class="fa fa-check"></i><b>5.2</b> Data output (O)</a><ul>
<li class="chapter" data-level="5.2.1" data-path="read-write.html"><a href="read-write.html#vector-data-2"><i class="fa fa-check"></i><b>5.2.1</b> Vector data</a></li>
<li class="chapter" data-level="5.2.2" data-path="read-write.html"><a href="read-write.html#raster-data-2"><i class="fa fa-check"></i><b>5.2.2</b> Raster data</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="read-write.html"><a href="read-write.html#file-formats"><i class="fa fa-check"></i><b>5.3</b> File formats</a><ul>
<li class="chapter" data-level="5.3.1" data-path="read-write.html"><a href="read-write.html#vector-formats"><i class="fa fa-check"></i><b>5.3.1</b> Vector formats</a></li>
<li class="chapter" data-level="5.3.2" data-path="read-write.html"><a href="read-write.html#raster-formats"><i class="fa fa-check"></i><b>5.3.2</b> Raster formats</a></li>
<li class="chapter" data-level="5.3.3" data-path="read-write.html"><a href="read-write.html#geodatabases"><i class="fa fa-check"></i><b>5.3.3</b> Geodatabases</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="read-write.html"><a href="read-write.html#visual-outputs"><i class="fa fa-check"></i><b>5.4</b> Visual outputs</a></li>
<li class="chapter" data-level="5.5" data-path="read-write.html"><a href="read-write.html#exercises-4"><i class="fa fa-check"></i><b>5.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i><b>6</b> References</a></li>
<li class="divider"></li>
<li><a href="http://robinlovelace.net/">Robin Lovelace</a></li>
<li><a href="https://nowosad.github.io/">Jakub Nowosad</a></li>
<li><a href="http://www.geographie.uni-jena.de/en/Muenchow.html">Jannes Muenchow</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Geocomputation with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="spatial-data-operations" class="section level1">
<h1><span class="header-section-number">4</span> Spatial data operations</h1>
<div id="prerequisites-2" class="section level2 unnumbered">
<h2>Prerequisites</h2>
<ul>
<li>This chapter requires <strong>tidyverse</strong>, <strong>sf</strong>, and <strong>spData</strong> packages:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(sf)
<span class="kw">library</span>(raster)
<span class="kw">library</span>(tidyverse)</code></pre></div>
<ul>
<li>You must have loaded the <code>world</code> data from the <strong>spData</strong> package:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(spData)</code></pre></div>
</div>
<div id="introduction-1" class="section level2">
<h2><span class="header-section-number">4.1</span> Introduction</h2>
<p>Spatial operations are an important component of any geospatial software and vital for many applications involving spatial data. There are clear overlaps between spatial and non-spatial operations. Common spatial attribute data processing tasks include spatial subsetting (as we will see in section <a href="spatial-data-operations.html#spatial-subsetting">4.2</a>), joining and aggregation (<a href="spatial-data-operations.html#spatial-joining-and-aggregation">4.3</a>). Each of these spatial operations has a non-spatial equivalent, as demonstrated in section <a href="attr.html#vector-attribute-manipulation">3.2</a> in the previous chapter.</p>
<p>Some operations covered in this chapter are unique to spatial data. A variety of <em>topological relations</em> can be used to subset/join vector geometries (by default <strong>sf</strong> uses the catch-all <em>intersects</em> but other relations such as <em>within</em> can be very useful), a topic that is explored in section <a href="spatial-data-operations.html#topological-relations">4.4</a>. New geometry data can be created by modifying existing spatial objects, using operations such as ‘buffer’ and ‘clip’, described in section <a href="spatial-data-operations.html#modifying-geometry-data">4.5</a>. Another unique aspect of spatial objects is distance. All features are related to each other in geographic space, and distance calculations can be used to find which spatial features are nearer or further away from a given point or each other, as we’ll see in section <a href="spatial-data-operations.html#distance-relations">4.6</a>. The final topic covered in this chapter is spatial raster operations <a href="spatial-data-operations.html#spatial-operations-on-raster-data">4.7</a>.</p>
<div class="rmdnote">
<p>
It is important to note that spatial operations that use two spatial objects rely on both objects having the same coordinate reference system, a topic that was introduced in <span class="citation">(<span class="citeproc-not-found" data-reference-id="ref"><strong>???</strong></span>)</span>(crs-intro) and which will be covered in more depth in Chapter 6.
</p>
</div>
</div>
<div id="spatial-subsetting" class="section level2">
<h2><span class="header-section-number">4.2</span> Spatial subsetting</h2>
<p>Spatial subsetting is the process of selecting only those features of a spatial object that in some way <em>intersect</em> with another spatial object. Note that ‘intersect’ in this context has a precise meaning: if <code>y</code> is used to subset features in a ‘target’ object of <code>x</code>, any features in <code>x</code> that touch, overlap or are within features in <code>y</code> will be selected. Intersect is the default operation for spatial subsetting but others can be used using the <code>op =</code> argument.<a href="references.html#fn22" class="footnoteRef" id="fnref22"><sup>22</sup></a></p>
<p>There are 9 well-defined operations that can be used for spatial subsetting, covered in section <a href="spatial-data-operations.html#topological-relations">4.4</a>. This may seem daunting but the good news is that you do not have to learn all of them separately: after you understand how to spatially subset objects that <em>intersect</em> another (via <code>st_intersects()</code>) it is easy to subset based on other types of spatial operation such as <code>st_touches()</code>, <code>st_crosses()</code> and <code>st_within()</code>. For this reason now we focus only on one of the spatial subsetting operations. We use <code>st_intersects()</code> instead of any of the others not only because it the default when subsetting with <code>[</code>, but also <code>st_intersects()</code> is useful as a ‘catch all’ that identifies all types of spatial relations.</p>
<p>In general terms, spatial subsetting is simply the spatial equivalent of <em>attribute subsetting</em>. However, to do spatial subsetting <em>two spatial objects are needed</em> the spatial relation between which is to be established. As with attribute subsetting, spatial subsetting is a <em>binary operation</em>: an object is either selected or not. As in section <a href="attr.html#vector-attribute-subsetting">3.2.1</a>, we start with base methods before describing how to do it in the <strong>tidyverse</strong>. <!-- todo: link to non-binary links, e.g. area-weighted spatial interpolation --></p>
<!-- ### Spatial subsetting in base R -->
<p>Attribute subsetting in base R is done with the <code>[</code> operator and passing into the square brackets a vector of class <code>integer</code> (whole numbers) or <code>logical</code> (a vector of <code>TRUE</code>s and <code>FALSE</code>s). This means <code>world[1:6, ]</code> subsets the first 6 countries of the world and that <code>world[world$area_km2 &lt; 10000, ]</code> returns the subset of countries that have a small surface area. For this chapter we will use countries in Africa, which can be generated using this method as follows:<a href="references.html#fn23" class="footnoteRef" id="fnref23"><sup>23</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">africa_wgs =<span class="st"> </span>world[world$continent ==<span class="st"> &quot;Africa&quot;</span>, ]</code></pre></div>
<p>To further set-up the input data, we will reproject the data to the coordinate reference system (CRS) 32630 (it’s EPSG code, explained in Chapter 6):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">africa =<span class="st"> </span><span class="kw">st_transform</span>(africa_wgs, <span class="dt">crs =</span> <span class="dv">32630</span>)</code></pre></div>
<p><em>Spatial</em> subsetting in base R use the same method as attribute subsetting, except <em>another spatial object</em> is placed inside the square brackets in the place of an <code>integer</code> or <code>logical</code> vector. This is a concise and consistent syntax, as shown in the next code chunk. Let’s test it with a hypothetical scenario: we want to subset all countries within 20 degrees of the point where the equator (where latitude = 0 degrees) intersects the prime meridian (longitude = 0 degrees), as illustrated in Figure <a href="spatial-data-operations.html#fig:globe">4.1</a>. The subsetting object is created below. Note that this must have the same CRS as the target object (set with the <code>crs</code> argument):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">center =<span class="st"> </span><span class="kw">st_sf</span>(<span class="kw">st_sfc</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)), <span class="dt">crs =</span> <span class="dv">4326</span>))
buff =<span class="st"> </span><span class="kw">st_buffer</span>(<span class="dt">x =</span> center, <span class="dt">dist =</span> <span class="dv">20</span>)
buff =<span class="st"> </span><span class="kw">st_transform</span>(buff, <span class="dv">32630</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:globe"></span>
<img src="figures/globe.png" alt="Hypothetical subsetting scenario: select all countries which intersect with a circle of 20 degrees in radius around planet Earth. Figure created with the **[globe](https://cran.r-project.org/package=globe)** package." width="250" />
<p class="caption">
Figure 4.1: Hypothetical subsetting scenario: select all countries which intersect with a circle of 20 degrees in radius around planet Earth. Figure created with the <strong><a href="https://cran.r-project.org/package=globe">globe</a></strong> package.
</p>
</div>
<p>The data to be subset, or ‘target layer’, is the <code>africa</code> created above, which has a projected CRS (<code>32630</code>). Now that the input data is set-up, the spatial subsetting operation is a single, concise command:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">africa_buff =<span class="st"> </span>africa[buff, ]</code></pre></div>
<p>Note that the command emits a message: about assuming <code>planar coordinates</code>. This is because spatial operations (especially distance and area calculations) cannot be assumed to be accurate in a geographic (longitude/latitude) CRS. In this case there is a clear justification: the data is close to the equator where there is least distortion caused by the curvature of the earth, and the example illustrates the method, which would more usually be used on pojected (‘planar’) data. In any case, the spatial subsetting clearly worked. As illustrated by Figure <a href="spatial-data-operations.html#fig:africa-buff">4.2</a>, only countries which spatially intersect with the giant circle are returned:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(africa_buff[<span class="st">&quot;pop&quot;</span>])
<span class="kw">plot</span>(buff, <span class="dt">add =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:africa-buff"></span>
<img src="figures/africa-buff-1.png" alt="Subset of the `africa` data selected based on their intersection with a circle 20 degrees in radius with a center point at 0 degrees longitude and 0 degrees latitude." width="576" />
<p class="caption">
Figure 4.2: Subset of the <code>africa</code> data selected based on their intersection with a circle 20 degrees in radius with a center point at 0 degrees longitude and 0 degrees latitude.
</p>
</div>
<p>Note that countries that only just touch the giant circle are selected such as the large country at the north of plot (Algeria). <code>st_relates()</code> includes countries that only touch (but are not within or overlapping with) the selection object. Other spatial subsetting operations such as <code>st_within()</code> are more conservative, as shown in section <a href="spatial-data-operations.html#topological-relations">4.4</a>.</p>
<p>Before we progress to explore the differences between different spatial subsetting operations, it is worth seeing alternative ways to achieve the same result, to deepen understanding of what is going on ‘under the hood’ (vital for developing advanced geocomputation applications). The second way to reproduce the subsetting operation illustrated in Figure <a href="spatial-data-operations.html#fig:africa-buff">4.2</a> simply involves expanding the operation over 2 lines:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sel_buff =<span class="st"> </span><span class="kw">st_intersects</span>(<span class="dt">x =</span> africa, <span class="dt">y =</span> buff, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)
africa_buff2 =<span class="st"> </span>africa[sel_buff, ]</code></pre></div>
<p>The third way is essentially the same as the second, but uses the <code>filter()</code> function introduced in section <a href="attr.html#vector-attribute-subsetting">3.2.1</a>, forming the foundations of a ‘tidy’ spatial data analysis workflow. If you already use <strong>dplyr</strong> for data manipulation, this way should seem familiar:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">africa_buff3 =<span class="st"> </span>africa %&gt;%
<span class="st">  </span><span class="kw">filter</span>(<span class="kw">st_intersects</span>(<span class="dt">x =</span> ., <span class="dt">y =</span> buff, <span class="dt">sparse =</span> <span class="ot">FALSE</span>))</code></pre></div>
<p>How can we be sure that the results obtained through the 4 subsetting operations demonstrated above? We can test them as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">identical</span>(<span class="dt">x =</span> africa_buff, <span class="dt">y =</span> africa_buff2)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">identical</span>(<span class="dt">x =</span> africa_buff, <span class="dt">y =</span> africa_buff3)
<span class="co">#&gt; [1] FALSE</span></code></pre></div>
<p>The reason that the third spatially subset object (<code>africa_buff3</code>) is not identical is that <strong>dplyr</strong> changes the row names:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">row.names</span>(africa_buff))
<span class="co">#&gt; [1] &quot;2&quot;  &quot;14&quot; &quot;15&quot; &quot;27&quot; &quot;32&quot; &quot;33&quot;</span>
<span class="kw">head</span>(<span class="kw">row.names</span>(africa_buff3))
<span class="co">#&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot;</span></code></pre></div>
<p>If the row names are re-set, the objects become identical:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attr</span>(africa_buff3, <span class="st">&quot;row.names&quot;</span>) =<span class="st"> </span><span class="kw">attr</span>(<span class="dt">x =</span> africa_buff, <span class="st">&quot;row.names&quot;</span>)
<span class="kw">identical</span>(africa_buff, africa_buff3)
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<div class="rmdnote">
<p>
This discarding of row names is not something that is specific to spatial data, as illustrated in the code chunk below:<a href="references.html#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>
</p>











<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">row.names</span>(africa[africa$subregion ==<span class="st"> &quot;Northern Europe&quot;</span>, ])
<span class="co">#&gt; character(0)</span>
<span class="kw">row.names</span>(<span class="kw">filter</span>(africa, subregion ==<span class="st"> &quot;Northern Europe&quot;</span>))
<span class="co">#&gt; character(0)</span></code></pre></div>
</div>
<div id="spatial-joining-and-aggregation" class="section level2">
<h2><span class="header-section-number">4.3</span> Spatial joining and aggregation</h2>
<p>Like attribute data aggregation, covered in section <a href="attr.html#vector-attribute-aggregation">3.2.2</a>, spatial data aggregation is a way of <em>condensing</em> data. Aggregated data show some statistic about a variable (typically mean average or total) in relation to some kind of <em>grouping variable</em>. For attribute data aggregation the grouping variable is another variable, typically one with few unique values relative to the number of rows. The <code>continent</code> variable in the <code>world</code> dataset is a good example: there are only 8 unique continents but 177 countries. In section <a href="attr.html#vector-attribute-aggregation">3.2.2</a> the aggregation process condensed the <code>world</code> dataset down into only 8 rows and an aggregated <code>pop</code> variable representing the total population per continent (see Figure <a href="attr.html#fig:continent-pop">3.1</a>).</p>
<p>Spatial data aggregation is the same conceptually but uses a <em>spatial</em> grouping object: the <em>output</em> is the same, in terms of number of rows/features and geometry, as the <em>grouping object</em>, but with new variables corresponding to the input dataset. As with spatial subsetting, spatial aggregation operations work by extending existing functions. Since mid-2017 (with the release of <strong>sf</strong> <code>0.5-3</code>) the base R function <code>aggregate()</code> works with a spatial object as a grouping variable.</p>
<p>Building on the example presented the previous section (<a href="spatial-data-operations.html#spatial-subsetting">4.2</a>), we demonstrate this by aggregating the population of countries that intersect with the buffer represented by the circular <code>buff</code> object created in the previous section.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buff_agg =<span class="st"> </span><span class="kw">aggregate</span>(<span class="dt">x =</span> africa[<span class="st">&quot;pop&quot;</span>], <span class="dt">by =</span> buff, <span class="dt">FUN =</span> sum)</code></pre></div>
<p>The result, <code>buff_agg</code>, is a spatial object with the same geometry as <code>by</code> (the circular buffer in this case) but with an additional variable, <code>pop</code> reporting summary statistics for all features in <code>x</code> that intersect with <code>by</code> (the total population of the countries that touch the buffer in this case). Plotting the result (with <code>plot(buff_agg)</code>) shows that the operation does not really make sense: Figure <a href="spatial-data-operations.html#fig:buff-agg">4.3</a> shows a population of over half a billion people mostly located in a giant circle floating off the west coast of Africa!</p>
<div class="figure" style="text-align: center"><span id="fig:buff-agg"></span>
<img src="figures/buff-agg-1.png" alt="Result of spatial aggregation showing the total population of countries that intersect with a large circle whose center lies at 0 degrees longitude and latitude" width="576" />
<p class="caption">
Figure 4.3: Result of spatial aggregation showing the total population of countries that intersect with a large circle whose center lies at 0 degrees longitude and latitude
</p>
</div>
<p>The results of the spatial aggregation exercise presented in Figure <a href="spatial-data-operations.html#fig:buff-agg">4.3</a> are unrealistic for three reasons:</p>
<ul>
<li>People do not live in the sea (the geometry of the aggregating object is not appropriate for the geometry target object).</li>
<li>This method would ‘double count’ countries whose borders cross aggregating polygons when multiple, spatially contiguous, features are used as the aggregating object.</li>
<li>It is wrong to assume that all the people living in countries that <em>touch</em> the buffer reside <em>within</em> it (the default spatial operator <code>st_intersects()</code> is too ‘greedy’). The most extreme example of this is Algeria, the most northerly country selected: the spatial aggregation operation assumes that all 39 million Algerian citizens reside in the tiny southerly tip that is within the circular buffer.</li>
</ul>
<p>A number of methods can be used to overcome these issues, and generate a more realistic population attributed to the circular buffer illustrated in Figure <a href="spatial-data-operations.html#fig:buff-agg">4.3</a>. The simplest of these is to convert the country polygons into points representing their <em>geographic centroids</em> before aggregation, covered in section <a href="spatial-data-operations.html#modifying-geometry-data">4.5</a>. <!-- Todo: reference section where we demonstrate geographic centroid generation --> This would ensure that any spatially contiguous aggregating object covering the target object (the Earth in this case) would result in the same total: there would be no double counting. The estimated total population residing within the study area would be more realistic if geographic centroids were used. (The centroid of Algeria, for example, is far outside the aggregating buffer.)</p>
<p>Except in cases where the number of target features per aggregating feature is very large, or where the aggregating object is <em>spatially congruent</em> with the target (covered in section <a href="spatial-data-operations.html#spatial-congruence-and-areal-interpolation">4.3.1</a>), using centroids can also lead to errors due to boundary effects: imagine a buffer that covers a large area but contains no centroids. These issues can be tackled when aggregating areal target data with areal interpolation.</p>
<div id="spatial-congruence-and-areal-interpolation" class="section level3">
<h3><span class="header-section-number">4.3.1</span> Spatial congruence and areal interpolation</h3>
<p>Spatial congruence is an important concept related to spatial aggregation. An <em>aggregating object</em> object (which we will refer to as <code>y</code>, representing the buffer object in the previous section) is <em>congruent</em> with the target object (<code>x</code>, representing the countries in the previous section) if the two objects have shared borders. Often this is the case for administrative boundary data, whereby the larger units (e.g. Middle Layer Super Output Areas in the UK) are composed of many smaller units (Output Areas in this case, see <a href="https://www.ons.gov.uk/methodology/geography/ukgeographies/censusgeography">ons.gov.uk</a> for further details).</p>
<p><em>Incongruent</em> aggregating objects, by contrast, do not share common borders with the target <span class="citation">(Qiu, Zhang, and Zhou <a href="#ref-qiu_development_2012">2012</a>)</span>. This is problematic for spatial aggregation (and other spatial operations) illustrated in Figure <a href="spatial-data-operations.html#fig:areal-example">4.4</a>. Areal interpolation resolves this issue. A number of algorithms have been developed for areal interpolation, including area weighted and pycnophylactic interpolation methods task <span class="citation">(Tobler <a href="#ref-tobler_smooth_1979">1979</a>)</span>.</p>
<div class="figure" style="text-align: center"><span id="fig:areal-example"></span>
<img src="figures/areal-example-1.png" alt="Illustration of congruent (left) and incongruent (right) areal units." width="576" />
<p class="caption">
Figure 4.4: Illustration of congruent (left) and incongruent (right) areal units.
</p>
</div>
<p>The simplest useful method for spatial interpolation is <em>area weighted</em> spatial interpolation. This is implemented in <code>st_interpolate_aw()</code>, as demonstrated below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buff_agg_aw =<span class="st"> </span><span class="kw">st_interpolate_aw</span>(<span class="dt">x =</span> africa[<span class="st">&quot;pop&quot;</span>], <span class="dt">to =</span> buff, <span class="dt">extensive =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; Warning in st_interpolate_aw(x = africa[&quot;pop&quot;], to = buff, extensive =</span>
<span class="co">#&gt; TRUE): st_interpolate_aw assumes attributes are constant over areas of x</span></code></pre></div>
<!-- - `aggregate.sf()` - aggregate an sf object, possibly union-ing geometries -->
<!-- - disaggregation?? `st_cast()` - https://github.com/edzer/sfr/wiki/migrating -->
<!-- - `group_by()` + `summarise()` - potential errors -->
<!-- - ? generalization **rmapsharper** - https://github.com/ateucher/rmapshaper -->
<!-- `st_union` -->
</div>
<div id="non-overlapping-joins" class="section level3">
<h3><span class="header-section-number">4.3.2</span> Non-overlapping joins</h3>
<!-- e.g. two point's datasets (non-overlapping) -->
<!-- e.g. two point's datasets (overlapping) -->
<!-- ? topological problems of joining lines/polygons? -->
<!-- joining different types (e.g. points + polygons = geometry) -> save as GPKG? -->
<!-- `merge()`; `st_interpolate_aw()` -->
</div>
</div>
<div id="topological-relations" class="section level2">
<h2><span class="header-section-number">4.4</span> Topological relations</h2>
<!-- http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html -->
<!-- https://edzer.github.io/sfr/articles/sf3.html -->
<!-- https://github.com/edzer/sfr/wiki/migrating#relevant-commands-exported-by-rgeos -->
<!-- Relations and inverse relations -->
<!-- http://desktop.arcgis.com/en/arcmap/latest/extensions/data-reviewer/types-of-spatial-relationships-that-can-be-validated.htm -->
<!-- Topological relations: + difference between datatypes -->
<!-- ?geos_binary_pred -->
<!-- Distance relations -->
<!-- Subset (1) points in polygons <-> (2) -->
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a1 =<span class="st"> </span><span class="kw">st_polygon</span>(<span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(-<span class="dv">1</span>, -<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">1</span>, -<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>), <span class="kw">c</span>(-<span class="dv">1</span>, -<span class="dv">1</span>))))
a2 =<span class="st"> </span><span class="kw">st_polygon</span>(<span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">0</span>))))
a =<span class="st"> </span><span class="kw">st_sfc</span>(a1, a2)

b1 =<span class="st"> </span>a1 *<span class="st"> </span><span class="fl">0.5</span>
b2 =<span class="st"> </span>a2 *<span class="st"> </span><span class="fl">0.4</span> +<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="fl">0.5</span>)
b =<span class="st"> </span><span class="kw">st_sfc</span>(b1, b2)

l1 =<span class="st"> </span><span class="kw">st_linestring</span>(<span class="dt">x =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">3</span>, -<span class="dv">1</span>, <span class="dv">1</span>), , <span class="dv">2</span>))
l2 =<span class="st"> </span><span class="kw">st_linestring</span>(<span class="dt">x =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="dv">1</span>, -<span class="dv">1</span>, -<span class="fl">0.5</span>, <span class="dv">1</span>), , <span class="dv">2</span>))
l =<span class="st"> </span><span class="kw">st_sfc</span>(l1, l2)

p =<span class="st"> </span><span class="kw">st_multipoint</span>(<span class="dt">x =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">1</span>, -<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.5</span>), , <span class="dv">2</span>))

<span class="kw">plot</span>(a, <span class="dt">border =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">axes =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(b, <span class="dt">border =</span> <span class="st">&quot;green&quot;</span>, <span class="dt">add =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(l, <span class="dt">add =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(p, <span class="dt">add =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="figures/unnamed-chunk-18-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>Equals: <!-- https://postgis.net/docs/ST_Equals.html --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_equals</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p>Contains: <!-- https://postgis.net/docs/ST_Contains.html --> <!-- https://postgis.net/docs/ST_ContainsProperly.html --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_contains</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)
<span class="kw">st_contains_properly</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p>Covers: <!-- https://postgis.net/docs/ST_Covers.html --> <!-- https://postgis.net/docs/ST_CoveredBy.html --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_covers</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)
<span class="kw">st_covered_by</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p>Within: <!-- https://postgis.net/docs/ST_Within.html --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_within</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p>Overlaps: <!-- https://postgis.net/docs/ST_Overlaps.html --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_overlaps</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p>Intersects: <!-- https://postgis.net/docs/ST_Intersects.html --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_intersects</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p>Disjoint: <!-- https://postgis.net/docs/ST_Disjoint.html --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_disjoint</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p>Touches: <!-- https://postgis.net/docs/ST_Touches.html --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_touches</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p>Crosses: <!-- https://postgis.net/docs/ST_Crosses.html --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_crosses</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p>DE9-IM - <a href="https://en.wikipedia.org/wiki/DE-9IM" class="uri">https://en.wikipedia.org/wiki/DE-9IM</a> <!-- https://edzer.github.io/sfr/reference/st_relate.html --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_relate</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div>
<!-- examples (points/polygons) -->
<!-- examples (points/lines) -->
<!-- examples (lines/polygons) -->
<!-- TODO? create a series of polygons distributed evenly over the surface of the Earth and clip them. -->
<!-- ```{r} -->
<!-- set.seed(2018) -->
<!-- blob_points = st_sample(x = world, size = 2) -->
<!-- blobs = st_buffer(x = blob_points, dist = 1) -->
<!-- plot(blobs) -->
</div>
<div id="modifying-geometry-data" class="section level2">
<h2><span class="header-section-number">4.5</span> Modifying geometry data</h2>
<p>Spatial clipping is a form of spatial subsetting that involves changes to the <code>geometry</code> columns of at least some of the affected features.</p>
<p>Clipping can only apply to features more complex than points: lines, polygons and their ‘multi’ equivalents. To illustrate the concept we will start with a simple example: two overlapping circles with a centerpoint 1 unit away from each other and radius of 1:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b =<span class="st"> </span><span class="kw">st_sfc</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>)), <span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>))) <span class="co"># create 2 points</span>
b =<span class="st"> </span><span class="kw">st_buffer</span>(b, <span class="dt">dist =</span> <span class="dv">1</span>) <span class="co"># convert points to circles</span>
l =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>)
<span class="kw">plot</span>(b)
<span class="kw">text</span>(<span class="dt">x =</span> <span class="kw">c</span>(-<span class="fl">0.5</span>, <span class="fl">1.5</span>), <span class="dt">y =</span> <span class="dv">1</span>, <span class="dt">labels =</span> l) <span class="co"># add text</span></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:points"></span>
<img src="figures/points-1.png" alt="Overlapping circles." width="576" />
<p class="caption">
Figure 4.5: Overlapping circles.
</p>
</div>
<p>Imagine you want to select not one circle or the other, but the space covered by both <code>x</code> <em>and</em> <code>y</code>. This can be done using the function <code>st_intersection()</code>, illustrated using objects named <code>x</code> and <code>y</code> which represent the left and right-hand circles:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x =<span class="st"> </span>b[<span class="dv">1</span>]
y =<span class="st"> </span>b[<span class="dv">2</span>]
x_and_y =<span class="st"> </span><span class="kw">st_intersection</span>(x, y)
<span class="kw">plot</span>(b)
<span class="kw">plot</span>(x_and_y, <span class="dt">col =</span> <span class="st">&quot;lightgrey&quot;</span>, <span class="dt">add =</span> <span class="ot">TRUE</span>) <span class="co"># color intersecting area</span></code></pre></div>
<p><img src="figures/unnamed-chunk-29-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>The subsequent code chunk demonstrate how this works for all combinations of the ‘venn’ diagram representing <code>x</code> and <code>y</code>, inspired by <a href="http://r4ds.had.co.nz/transform.html#logical-operators">Figure 5.1</a> of the book R for Data Science <span class="citation">(Grolemund and Wickham <a href="#ref-grolemund_r_2016">2016</a>)</span>. <!-- Todo: reference r4ds --></p>
<div class="figure" style="text-align: center"><span id="fig:venn-clip"></span>
<img src="figures/venn-clip-1.png" alt="Spatial equivalents of logical operators" width="576" />
<p class="caption">
Figure 4.6: Spatial equivalents of logical operators
</p>
</div>
<p>To illustrate the relationship between subsetting and clipping spatial data, we will subset points that cover the bounding box of the circles <code>x</code> and <code>y</code> in Figure <a href="spatial-data-operations.html#fig:venn-clip">4.6</a>. Some points will be inside just one circle, some will be inside both and some will be inside neither. To generate the points will use a function not yet covered in this book, <code>st_sample()</code>.</p>
<p>There are two different ways to subset points that fit into combinations of the circles: via clipping and logical operators. But first we must generate some points. We will use the <em>simple random</em> sampling strategy to sample from a box representing the extent of <code>x</code> and <code>y</code>, using the code below to generate the situation plotted in Figure <a href="spatial-data-operations.html#fig:venn-subset">4.7</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bb =<span class="st"> </span><span class="kw">st_bbox</span>(<span class="kw">st_union</span>(x, y))
pmat =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(bb[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">2</span>)]), <span class="dt">ncol =</span> <span class="dv">2</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)
box =<span class="st"> </span><span class="kw">st_polygon</span>(<span class="kw">list</span>(pmat))
<span class="kw">set.seed</span>(<span class="dv">2017</span>)
p =<span class="st"> </span><span class="kw">st_sample</span>(<span class="dt">x =</span> box, <span class="dt">size =</span> <span class="dv">10</span>)
<span class="kw">plot</span>(box)
<span class="kw">plot</span>(x, <span class="dt">add =</span> T)
<span class="kw">plot</span>(y, <span class="dt">add =</span> T)
<span class="kw">plot</span>(p, <span class="dt">add =</span> T)
<span class="kw">text</span>(<span class="dt">x =</span> <span class="kw">c</span>(-<span class="fl">0.5</span>, <span class="fl">1.5</span>), <span class="dt">y =</span> <span class="dv">1</span>, <span class="dt">labels =</span> l)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:venn-subset"></span>
<img src="figures/venn-subset-1.png" alt="Randomly distributed points within the bounding box enclosing circles x and y." width="576" />
<p class="caption">
Figure 4.7: Randomly distributed points within the bounding box enclosing circles x and y.
</p>
</div>
</div>
<div id="distance-relations" class="section level2">
<h2><span class="header-section-number">4.6</span> Distance relations</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_distance</span>(a, b)</code></pre></div>
</div>
<div id="spatial-operations-on-raster-data" class="section level2">
<h2><span class="header-section-number">4.7</span> Spatial operations on raster data</h2>
<p>This section builds on <a href="attr.html#manipulating-raster-objects">3.3</a>, which highlights various basic methods for manipulating raster datasets, to demonstrate more advanced and explicitly spatial raster operations, and uses the same objects <code>r</code> and <code>r_2</code>.</p>
<div id="map-algebra-local-focal-zonal-global" class="section level3">
<h3><span class="header-section-number">4.7.1</span> Map algebra: local, focal, zonal, global</h3>
<p>Raster processing is really fast because it only implicitly stores coordinates, that is we can calculate the coordinate of a raster cell due to its matrix position and the help of the resolution and the origin. For the processing, however, the geographic position of a cell is barely relevant as long as we make sure that the cell position is still the same after the processing (one-to-one locational correspondence). Additionally, if two or more raster datasets share the same extent, projection and the resolution, one could treat them as matrixes for the processing. This is exactly what map algebra is doing. First, it checks the headers of the rasters on which to perform any algebraic operation, and only if they correspondent to each other, the processing goes on. And secondly, map algebra retains the so-called one-to-one locational correspondence. This is where it substantially differs from matrix algebra which changes positions when for example multiplying or dividing matrixes.</p>
<p>Map algebra (or cartographic modeling) divides raster operations into four subclasses <span class="citation">(Tomlin <a href="#ref-tomlin_geographic_1990">1990</a>)</span>, with each of them either working on one or several grids simultaneously:</p>
<ol style="list-style-type: decimal">
<li><em>Local</em> or per-cell operations.</li>
<li><em>Focal</em> or neighborhood operations. Most often the output cell value is the result of a 3 x 3 input cell block.</li>
<li><em>Zonal</em> operations are similar to focal operations but instead of a predefined neighborhood, classes, which can take on any, i.e. also an irregular size and shape, are the basis for calculations.</li>
<li><em>Global</em> or per-raster operations, that means the output cell derives its value potentially from one or several entire rasters</li>
</ol>
<p>This classification scheme uses basically the number of cells involved in a processing step as distinguishing feature. Of course, one can classify raster operations based on other characteristics such as discipline. Think, for instance, of terrain, hydrological analysis or image classifications. In the following paragraphs, we will explain each of the four map algebra operations by example.</p>
<p><strong>Local</strong> operations comprise all cell-by-cell operations in one or several layers. A good example is the classification of intervals of numeric values into groups such as grouping a digital elevation model into low (class 1), middle (class 2) and high elevations (class 3). Using the <code>reclassify()</code> command, we need first to construct a reclassification matrix, where the first column corresponds to the lower and the second column to the upper end of the class. The third column represents the new value for the specified ranges in column one and two. Here, we assign the raster values in the ranges 0–12, 12–24 and 24–36 are <em>reclassified</em> to take values 1, 2 and 3, respectively.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rcl =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">12</span>, <span class="dv">1</span>, <span class="dv">12</span>, <span class="dv">24</span>, <span class="dv">2</span>, <span class="dv">24</span>, <span class="dv">36</span>, <span class="dv">3</span>), <span class="dt">ncol =</span> <span class="dv">3</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)
recl =<span class="st"> </span><span class="kw">reclassify</span>(r, <span class="dt">rcl =</span> rcl)</code></pre></div>
<p>Raster algebra is another classical use case of local operations. This includes adding, subtracting and squaring two rasters. Raster algebra also allows logical operations such as finding all raster cells that are greater than a specific value (5 in our example below). The <strong>raster</strong> package allows all these operations in a way natural to R users. Please see the <code>Raster</code>-vignette for a more detailed description on algebraic operations (<code>vignette(&quot;Raster&quot;, package = &quot;raster&quot;)</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">r +<span class="st"> </span>r
r^<span class="dv">2</span>
<span class="kw">log</span>(r)
r &gt;<span class="st"> </span><span class="dv">5</span></code></pre></div>
<p>Instead of arithmetic operators, you can also use the <code>calc()</code> and <code>overlay()</code> functions. These functions are more efficient. So you should use them if you have to process large raster datasets. Additionally, they let you directly store an output file.</p>
<p>The calculation of the normalized difference vegetation index (NDVI) is one of the most famous local, i.e. pixel-by-pixel, raster operations. It ranges between - 1 and 1 with positive values indicating the presence of living plants (mostly &gt; 0.2). To calculate the NDVI, one uses the red and near-infrared bands of remotely sensed imagery (e.g., Landsat or Sentinel imagery) exploiting the fact that vegetation absorbs light heavily in the visible light spectrum, and especially in the red channel, while reflecting it in the near-infrared spectrum.</p>
<p><span class="math display">\[
\begin{split}
NDVI&amp;= \frac{\text{NIR} - \text{Red}}{\text{NIR} + \text{Red}}\\
\end{split}
\]</span> where NIR = near infrared channel Red = red channel</p>
<p>Predictive mapping is another interesting application of local raster operations. The response variable correspond to measured or observed points in space, for example, species richness, the presence of landslides, tree disease or crop yield. Consequently, we can easily retrieve space- or airborne predictor variables from various rasters (elevation, pH, precipitation, temperature, landcover, soil class, etc.). Subsequently, we model our response as a function of our predictors using <code>lm</code>, <code>glm</code>, <code>gam</code> or a machine-learning technique. To make a spatial prediction, all we have to do, is to apply the estimated coefficients to the predictor rasters, and summing up the resulting output rasters (<!--Chapter ??; -->see also <span class="citation">Muenchow et al. (<a href="#ref-muenchow_predictive_2013">2013</a>)</span>). <!-- add reference to chapter ecological modeling --></p>
<p>While local functions operate on one cell, though possibly from multiple layers, <strong>focal</strong> operations take into account a central cell and its neighbors. The neighborhood (also named kernel, filter or moving window) under consideration is typically of size 3-by-3 cells (that is the central cell and its eight surrounding neighbors) but can take on any other (not necessarily rectangular) shape as defined by the user. A focal operation applies an aggregation function to all cells within the specified neighborhood, uses the corresponding output as the new value for the the central cell, and moves on to the next central cell (Figure <a href="spatial-data-operations.html#fig:focal-example">4.8</a>). Other names for this operation are spatial filtering and convolution <span class="citation">(Burrough, McDonnell, and Lloyd <a href="#ref-burrough_principles_2015">2015</a>)</span>.</p>
<p>In R, we can use the <code>focal()</code> function to perform spatial filtering. We define the shape of the moving window with a <code>matrix</code> whose values correspond to weights. Secondly, the the <code>fun</code> argument lets us specify the function we wish to apply to this neighborhood. Here, we choose the minimum, but of course we can use any other function such as the the sum, the mean, the median, the mode, the maximum or the variance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">r_focal =<span class="st"> </span><span class="kw">focal</span>(r, <span class="dt">w =</span> <span class="kw">matrix</span>(<span class="dv">1</span>, <span class="dt">nrow =</span> <span class="dv">3</span>, <span class="dt">ncol =</span> <span class="dv">3</span>), <span class="dt">fun =</span> min)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:focal-example"></span>
<img src="figures/03_focal_example.png" alt="Input raster (left) and resulting output raster (right) due to a focal operation - summing up 3-by-3 windows" width="475" />
<p class="caption">
Figure 4.8: Input raster (left) and resulting output raster (right) due to a focal operation - summing up 3-by-3 windows
</p>
</div>
<p>We can quickly check if the output meets our expectations. In our example, the minimum value has to be always the upper left corner of the moving window (remember we have created the input raster by rowwise incrementing the cell values by one starting at the upper left corner). Of course, the <code>focal()</code>-function has computed the correct result. In this example, our weighting matrix consists only of 1s. This means each cell has the same weight on the output. If appropriate, you can change this by specifying different weights.</p>
<p>Focal functions or filters play a dominant role in image processing. Low-pass or smoothing filters use the mean function to remove extremes. In the case of categorical data, we can replace the mean with the mode, which is the most common value. By contrast, high-pass filters accentuate features. The line detection Laplace and Sobel filters might serve as an example here. Check the <code>focal()</code> help page how to use them in R.</p>
<p>Also, terrain processing uses heavily focal functions. Think, for instance, of the calculation of the slope, aspect and flow directions. The <code>terrain()</code> function lets you compute a few of these terrain characteristics but has not implemented all popular methods For example, the Zevenbergen and Thorne method to compute the slope is missing. Equally, many other terrain and GIS functions are <strong>not</strong> implemented in R such as curvatures, contributing areas, different wetness indexes, and many more. Fortunately, desktop GIS commonly provide these algorithms. In Chapter 13 we will learn how to access GIS functionality from within R. <!-- Reference 13-gis chapter --></p>
<p><em>Zonal</em> operations are similar to focal operations. The difference is that zonal filters can take on any shape instead of just a predefined window. Our grain size raster is a good example (Figure <a href="attr.html#fig:cont-cate-rasters">3.3</a>) because the different grain sizes are spread in an irregular fashion throughout the raster.</p>
<p>Now suppose, the first raster we created (<code>r</code>) represents elevation. To find the mean elevation for each grain size class, we can use the <code>zonal()</code> command. This kind of operation is also known as <em>zonal statistics</em> in the GIS world.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">z =<span class="st"> </span><span class="kw">zonal</span>(r, r_2, <span class="dt">fun =</span> <span class="st">&quot;mean&quot;</span>) %&gt;%
<span class="st">  </span>as.data.frame
z
<span class="co">#&gt;   zone mean</span>
<span class="co">#&gt; 1    1 16.8</span>
<span class="co">#&gt; 2    2 19.4</span>
<span class="co">#&gt; 3    3 19.8</span></code></pre></div>
<p>This returns the statistics for each category, here the mean altitude for each grain size class. Of course, we can add this statistic to the attribute table of the ratified raster (remember RAT stands for raster attribute table, see also previous chapter).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(r_2)[[<span class="dv">1</span>]] =<span class="st">  </span><span class="kw">cbind</span>(<span class="kw">levels</span>(r_2)[[<span class="dv">1</span>]], <span class="dt">mean_elev =</span> z$mean)</code></pre></div>
<p><em>Global</em> operations are a special case of zonal operations with the entire raster dataset representing a single zone. The most common global operations are descriptive statistics for the entire raster dataset such as the minimum or maximum (see previous chapter). Aside from that, global operations are also useful for the computation of distance and weight rasters. In the first case, one can calculate the distance from each cell to a specific target cell. For example, one might want to compute the distance to the nearest coast (see also <code>raster::distance()</code>). We might also want to consider topography, that means, we are not only interested in the pure distance but would like also to avoid the crossing of mountain ranges when going to the coast. To do so, we can weight the distance with elevation so that each additional altitudinal meter ‘prolongs’ the euclidean distance. Visibility and viewshed computations also belong to the family of global operations <!--(in the exercises of Chapter ?? you will compute a viewshed raster)-->. <!-- reference 13-gis chapter--></p>
</div>
<div id="mosaics" class="section level3">
<h3><span class="header-section-number">4.7.2</span> Mosaics</h3>
</div>
<div id="raster-aggregation-disaggregation-and-resampling" class="section level3">
<h3><span class="header-section-number">4.7.3</span> Raster aggregation, disaggregation and resampling</h3>
<!-- ## Spatial data creation -->
<!-- where should "area" example be? in this or the previous chapter? -->
<!-- Not here - I think this chapter should focus on geomtry data -->
<!-- `st_centroid()` -->
<!-- `st_buffer()` -->
<!-- http://r-spatial.org//r/2017/06/09/mapedit_0-2-0.html -->
<!-- Commented out - think this would be better in c3 (RL) -->
<!-- ```{r} -->
<!-- # add a new column -->
<!-- africa$area = set_units(st_area(africa), value = km^2) -->
<!-- africa$pop_density = africa$pop / africa$area -->
<!-- # OR -->
<!-- africa = africa %>% -->
<!--         mutate(area = set_units(st_area(.), value = km^2)) %>% -->
<!--         mutate(pop_density = pop / area) -->
<!-- ``` -->
<!-- Note that this has created a attributes for the area and population density variables: -->
<!-- ```{r} -->
<!-- attributes(africa$area) -->
<!-- attributes(africa$pop_density) -->
<!-- ``` -->
<!-- These can be set to `NULL` as follows: -->
<!-- ```{r} -->
<!-- attributes(africa$area) = NULL -->
<!-- attributes(africa$pop_density) = NULL -->
<!-- ``` -->
<!-- ## Spatial data transformation -->
<!-- changes classes; polygonize, etc-->
</div>
<div id="exercises-3" class="section level3">
<h3><span class="header-section-number">4.7.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li>Write code that subsets points that are contained within <code>x</code> <em>and</em> <code>y</code> (illustrated by the plot in the 2<sup>nd</sup> row and the 1<sup>st</sup> column in Figure <a href="spatial-data-operations.html#fig:venn-clip">4.6</a>).</li>
</ol>
<ul>
<li>Create a randomly located point with the command <code>st_point()</code> (refer back to section <a href="spatial-class.html#sfg">2.1.4.2</a> to see how to create spatial data ‘from scratch’).</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>Write code that uses functions <code>aggregate()</code> and <code>st_buffer()</code> to answers the following question: What proportion of the world’s population lives in countries that intersect a circle with a 10 degree radius of the intersection between the equator and the <a href="https://en.wikipedia.org/wiki/9th_meridian_east">9<sup>th</sup> meridian</a>? (Advanced challenge: find the point with the highest number of people within a 10 degree radius.)</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">center9 =<span class="st"> </span><span class="kw">st_sf</span>(<span class="kw">st_sfc</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(-<span class="dv">9</span>, <span class="dv">0</span>)), <span class="dt">crs =</span> <span class="dv">4326</span>))
buff9 =<span class="st"> </span><span class="kw">st_buffer</span>(center9, <span class="dt">dist =</span> <span class="dv">10</span>)
<span class="co">#&gt; Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs): st_buffer does</span>
<span class="co">#&gt; not correctly buffer longitude/latitude data, dist needs to be in decimal</span>
<span class="co">#&gt; degrees.</span>
agg9 =<span class="st"> </span><span class="kw">aggregate</span>(world[<span class="st">&quot;pop&quot;</span>], buff9, <span class="dt">FUN =</span> sum)
<span class="co">#&gt; although coordinates are longitude/latitude, it is assumed that they are planar</span>
agg9$pop /<span class="st"> </span><span class="kw">sum</span>(world$pop, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 0.00998</span></code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>Assuming that people are evenly distributed across countries, estimate the population living <em>within</em> the circle created to answer the previous question.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">interp9 =<span class="st"> </span><span class="kw">st_interpolate_aw</span>(<span class="dt">x =</span> world[<span class="st">&quot;pop&quot;</span>], <span class="dt">to =</span> buff9, <span class="dt">extensive =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; Warning in st_interpolate_aw(x = world[&quot;pop&quot;], to = buff9, extensive =</span>
<span class="co">#&gt; TRUE): st_interpolate_aw assumes attributes are constant over areas of x</span></code></pre></div>
<!-- Raster exercises-->
<ol start="4" style="list-style-type: decimal">
<li>Use <code>data(dem, package = &quot;RQGIS&quot;)</code>, and reclassify the elevation in three classes: low, middle and high. Secondly, compute the NDVI (<code>data(ndvi, package = &quot;RQGIS&quot;)</code>) and the mean elevation for each altitudinal class.</li>
<li>Apply a line detection filter to <code>data(dem, package = &quot;RQGIS&quot;)</code>.</li>
<li>Calculate the NDVI of a Landsat image. Use the Landsat image provided by the <strong>spDataLarge</strong> package (<code>system.file(&quot;raster/landsat.tif&quot;, package=&quot;spDataLarge&quot;)</code>).</li>
<li>This <a href="https://stackoverflow.com/questions/35555709/global-raster-of-geographic-distances">post</a> shows how to use <code>raster::distance()</code>. Extract Spain, calculate a distance raster and weight it with elevation. Finally, compute the difference between the raster using the euclidean distance and the raster weighted by elevation. (Hint: Have a look at <code>getData()</code> to retrieve a digital elevation model for Spain.)</li>
</ol>

</div>
</div>
</div>
<h3> References</h3>
<div id="refs" class="references">
<div id="ref-qiu_development_2012">
<p>Qiu, Fang, Caiyun Zhang, and Yuhong Zhou. 2012. “The Development of an Areal Interpolation ArcGIS Extension and a Comparative Study.” <em>GIScience &amp; Remote Sensing</em> 49 (5): 644–63. doi:<a href="https://doi.org/10.2747/1548-1603.49.5.644">10.2747/1548-1603.49.5.644</a>.</p>
</div>
<div id="ref-tobler_smooth_1979">
<p>Tobler, Waldo R. 1979. “Smooth Pycnophylactic Interpolation for Geographical Regions.” <em>Journal of the American Statistical Association</em> 74 (367): 519–30. doi:<a href="https://doi.org/10.1080/01621459.1979.10481647">10.1080/01621459.1979.10481647</a>.</p>
</div>
<div id="ref-grolemund_r_2016">
<p>Grolemund, Garrett, and Hadley Wickham. 2016. <em>R for Data Science</em>. 1 edition. O’Reilly Media.</p>
</div>
<div id="ref-tomlin_geographic_1990">
<p>Tomlin, C. Dana. 1990. <em>Geographic Information Systems and Cartographic Modeling</em>. Englewood Cliffs, N.J: Prentice Hall.</p>
</div>
<div id="ref-muenchow_predictive_2013">
<p>Muenchow, Jannes, Achim Bräuning, Eric Frank Rodríguez, and Henrik von Wehrden. 2013. “Predictive Mapping of Species Richness and Plant Species’ Distributions of a Peruvian Fog Oasis Along an Altitudinal Gradient.” <em>Biotropica</em> 45 (5): 557–66. doi:<a href="https://doi.org/10.1111/btp.12049">10.1111/btp.12049</a>.</p>
</div>
<div id="ref-burrough_principles_2015">
<p>Burrough, P. A., Rachael McDonnell, and Christopher D. Lloyd. 2015. <em>Principles of Geographical Information Systems</em>. Third edition. Oxford ; New York: Oxford University Press.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="22">
<li id="fn22"><p>Interested readers can see this default value of <code>op</code> set in the first line of the function call by entering its long-form name into the console: <code>sf:::`[.sf`</code><a href="spatial-data-operations.html#fnref22">↩</a></p></li>
<li id="fn23"><p>Recall that we can also subset simple features using the <code>filter()</code> function, e.g. with <code>filter(world, continent == &quot;Africa&quot;)</code><a href="spatial-data-operations.html#fnref23">↩</a></p></li>
<li id="fn1"><p><strong>dplyr</strong> discards row names by design. For further discussion of this decision, and some controversy, see the (closed) issue <a href="https://github.com/tidyverse/dplyr/issues/366">#366</a> in the package’s issue tracker.<a href="intro.html#fnref1">↩</a></p></li></ol></div></div><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">row.names</span>(africa[africa$subregion ==<span class="st"> &quot;Northern Europe&quot;</span>, ])<span class="co">#&gt; character(0)</span><span class="kw">row.names</span>(<span class="kw">filter</span>(africa, subregion ==<span class="st"> &quot;Northern Europe&quot;</span>))<span class="co">#&gt; character(0)</span></code></pre></div></div><div id="spatial-joining-and-aggregation" class="section level2"><h2><span class="header-section-number">4.3</span> Spatial joining and aggregation</h2><p>Like attribute data aggregation, covered in section <a href="attr.html#vector-attribute-aggregation">3.2.2</a>, spatial data aggregation is a way of <em>condensing</em> data. Aggregated data show some statistic about a variable (typically mean average or total) in relation to some kind of <em>grouping variable</em>. For attribute data aggregation the grouping variable is another variable, typically one with few unique values relative to the number of rows. The <code>continent</code> variable in the <code>world</code> dataset is a good example: there are only 8 unique continents but 177 countries. In section <a href="attr.html#vector-attribute-aggregation">3.2.2</a> the aggregation process condensed the <code>world</code> dataset down into only 8 rows and an aggregated <code>pop</code> variable representing the total population per continent (see Figure <a href="attr.html#fig:continent-pop">3.1</a>).</p><p>Spatial data aggregation is the same conceptually but uses a <em>spatial</em> grouping object: the <em>output</em> is the same, in terms of number of rows/features and geometry, as the <em>grouping object</em>, but with new variables corresponding to the input dataset. As with spatial subsetting, spatial aggregation operations work by extending existing functions. Since mid-2017 (with the release of <strong>sf</strong> <code>0.5-3</code>) the base R function <code>aggregate()</code> works with a spatial object as a grouping variable.</p><p>Building on the example presented the previous section (<a href="spatial-data-operations.html#spatial-subsetting">4.2</a>), we demonstrate this by aggregating the population of countries that intersect with the buffer represented by the circular <code>buff</code> object created in the previous section.</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buff_agg =<span class="st"> </span><span class="kw">aggregate</span>(<span class="dt">x =</span> africa[<span class="st">&quot;pop&quot;</span>], <span class="dt">by =</span> buff, <span class="dt">FUN =</span> sum)</code></pre></div><p>The result, <code>buff_agg</code>, is a spatial object with the same geometry as <code>by</code> (the circular buffer in this case) but with an additional variable, <code>pop</code> reporting summary statistics for all features in <code>x</code> that intersect with <code>by</code> (the total population of the countries that touch the buffer in this case). Plotting the result (with <code>plot(buff_agg)</code>) shows that the operation does not really make sense: Figure <a href="spatial-data-operations.html#fig:buff-agg">4.3</a> shows a population of over half a billion people mostly located in a giant circle floating off the west coast of Africa!</p><div class="figure" style="text-align: center"><span id="fig:buff-agg"></span><img src="figures/buff-agg-1.png" alt="Result of spatial aggregation showing the total population of countries that intersect with a large circle whose center lies at 0 degrees longitude and latitude" width="576" /><p class="caption">Figure 4.3: Result of spatial aggregation showing the total population of countries that intersect with a large circle whose center lies at 0 degrees longitude and latitude</p></div><p>The results of the spatial aggregation exercise presented in Figure <a href="spatial-data-operations.html#fig:buff-agg">4.3</a> are unrealistic for three reasons:</p><ul><li>People do not live in the sea (the geometry of the aggregating object is not appropriate for the geometry target object).</li><li>This method would ‘double count’ countries whose borders cross aggregating polygons when multiple, spatially contiguous, features are used as the aggregating object.</li><li>It is wrong to assume that all the people living in countries that <em>touch</em> the buffer reside <em>within</em> it (the default spatial operator <code>st_intersects()</code> is too ‘greedy’). The most extreme example of this is Algeria, the most northerly country selected: the spatial aggregation operation assumes that all 39 million Algerian citizens reside in the tiny southerly tip that is within the circular buffer.</li></ul><p>A number of methods can be used to overcome these issues, and generate a more realistic population attributed to the circular buffer illustrated in Figure <a href="spatial-data-operations.html#fig:buff-agg">4.3</a>. The simplest of these is to convert the country polygons into points representing their <em>geographic centroids</em> before aggregation, covered in section <a href="spatial-data-operations.html#modifying-geometry-data">4.5</a>. <!-- Todo: reference section where we demonstrate geographic centroid generation --> This would ensure that any spatially contiguous aggregating object covering the target object (the Earth in this case) would result in the same total: there would be no double counting. The estimated total population residing within the study area would be more realistic if geographic centroids were used. (The centroid of Algeria, for example, is far outside the aggregating buffer.)</p><p>Except in cases where the number of target features per aggregating feature is very large, or where the aggregating object is <em>spatially congruent</em> with the target (covered in section <a href="spatial-data-operations.html#spatial-congruence-and-areal-interpolation">4.3.1</a>), using centroids can also lead to errors due to boundary effects: imagine a buffer that covers a large area but contains no centroids. These issues can be tackled when aggregating areal target data with areal interpolation.</p><div id="spatial-congruence-and-areal-interpolation" class="section level3"><h3><span class="header-section-number">4.3.1</span> Spatial congruence and areal interpolation</h3><p>Spatial congruence is an important concept related to spatial aggregation. An <em>aggregating object</em> object (which we will refer to as <code>y</code>, representing the buffer object in the previous section) is <em>congruent</em> with the target object (<code>x</code>, representing the countries in the previous section) if the two objects have shared borders. Often this is the case for administrative boundary data, whereby the larger units (e.g. Middle Layer Super Output Areas in the UK) are composed of many smaller units (Output Areas in this case, see <a href="https://www.ons.gov.uk/methodology/geography/ukgeographies/censusgeography">ons.gov.uk</a> for further details).</p><p><em>Incongruent</em> aggregating objects, by contrast, do not share common borders with the target <span class="citation">(Qiu, Zhang, and Zhou <a href="#ref-qiu_development_2012">2012</a>)</span>. This is problematic for spatial aggregation (and other spatial operations) illustrated in Figure <a href="spatial-data-operations.html#fig:areal-example">4.4</a>. Areal interpolation resolves this issue. A number of algorithms have been developed for areal interpolation, including area weighted and pycnophylactic interpolation methods task <span class="citation">(Tobler <a href="#ref-tobler_smooth_1979">1979</a>)</span>.</p><div class="figure" style="text-align: center"><span id="fig:areal-example"></span><img src="figures/areal-example-1.png" alt="Illustration of congruent (left) and incongruent (right) areal units." width="576" /><p class="caption">Figure 4.4: Illustration of congruent (left) and incongruent (right) areal units.</p></div><p>The simplest useful method for spatial interpolation is <em>area weighted</em> spatial interpolation. This is implemented in <code>st_interpolate_aw()</code>, as demonstrated below:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">buff_agg_aw =<span class="st"> </span><span class="kw">st_interpolate_aw</span>(<span class="dt">x =</span> africa[<span class="st">&quot;pop&quot;</span>], <span class="dt">to =</span> buff, <span class="dt">extensive =</span> <span class="ot">TRUE</span>)<span class="co">#&gt; Warning in st_interpolate_aw(x = africa[&quot;pop&quot;], to = buff, extensive =</span><span class="co">#&gt; TRUE): st_interpolate_aw assumes attributes are constant over areas of x</span></code></pre></div><!-- - `aggregate.sf()` - aggregate an sf object, possibly union-ing geometries --><!-- - disaggregation?? `st_cast()` - https://github.com/edzer/sfr/wiki/migrating --><!-- - `group_by()` + `summarise()` - potential errors --><!-- - ? generalization **rmapsharper** - https://github.com/ateucher/rmapshaper --><!-- `st_union` --></div><div id="non-overlapping-joins" class="section level3"><h3><span class="header-section-number">4.3.2</span> Non-overlapping joins</h3><!-- e.g. two point's datasets (non-overlapping) --><!-- e.g. two point's datasets (overlapping) --><!-- ? topological problems of joining lines/polygons? --><!-- joining different types (e.g. points + polygons = geometry) -> save as GPKG? --><!-- `merge()`; `st_interpolate_aw()` --></div></div><div id="topological-relations" class="section level2"><h2><span class="header-section-number">4.4</span> Topological relations</h2><!-- http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html --><!-- https://edzer.github.io/sfr/articles/sf3.html --><!-- https://github.com/edzer/sfr/wiki/migrating#relevant-commands-exported-by-rgeos --><!-- Relations and inverse relations --><!-- http://desktop.arcgis.com/en/arcmap/latest/extensions/data-reviewer/types-of-spatial-relationships-that-can-be-validated.htm --><!-- Topological relations: + difference between datatypes --><!-- ?geos_binary_pred --><!-- Distance relations --><!-- Subset (1) points in polygons <-> (2) --><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a1 =<span class="st"> </span><span class="kw">st_polygon</span>(<span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(-<span class="dv">1</span>, -<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">1</span>, -<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>), <span class="kw">c</span>(-<span class="dv">1</span>, -<span class="dv">1</span>))))a2 =<span class="st"> </span><span class="kw">st_polygon</span>(<span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">0</span>))))a =<span class="st"> </span><span class="kw">st_sfc</span>(a1, a2)b1 =<span class="st"> </span>a1 *<span class="st"> </span><span class="fl">0.5</span>b2 =<span class="st"> </span>a2 *<span class="st"> </span><span class="fl">0.4</span> +<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="fl">0.5</span>)b =<span class="st"> </span><span class="kw">st_sfc</span>(b1, b2)l1 =<span class="st"> </span><span class="kw">st_linestring</span>(<span class="dt">x =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">3</span>, -<span class="dv">1</span>, <span class="dv">1</span>), , <span class="dv">2</span>))l2 =<span class="st"> </span><span class="kw">st_linestring</span>(<span class="dt">x =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="dv">1</span>, -<span class="dv">1</span>, -<span class="fl">0.5</span>, <span class="dv">1</span>), , <span class="dv">2</span>))l =<span class="st"> </span><span class="kw">st_sfc</span>(l1, l2)p =<span class="st"> </span><span class="kw">st_multipoint</span>(<span class="dt">x =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">1</span>, -<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.5</span>), , <span class="dv">2</span>))<span class="kw">plot</span>(a, <span class="dt">border =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">axes =</span> <span class="ot">TRUE</span>)<span class="kw">plot</span>(b, <span class="dt">border =</span> <span class="st">&quot;green&quot;</span>, <span class="dt">add =</span> <span class="ot">TRUE</span>)<span class="kw">plot</span>(l, <span class="dt">add =</span> <span class="ot">TRUE</span>)<span class="kw">plot</span>(p, <span class="dt">add =</span> <span class="ot">TRUE</span>)</code></pre></div><p><img src="figures/unnamed-chunk-18-1.png" width="576" style="display: block; margin: auto;" /></p><p>Equals: <!-- https://postgis.net/docs/ST_Equals.html --></p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_equals</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div><p>Contains: <!-- https://postgis.net/docs/ST_Contains.html --> <!-- https://postgis.net/docs/ST_ContainsProperly.html --></p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_contains</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)<span class="kw">st_contains_properly</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div><p>Covers: <!-- https://postgis.net/docs/ST_Covers.html --> <!-- https://postgis.net/docs/ST_CoveredBy.html --></p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_covers</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)<span class="kw">st_covered_by</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div><p>Within: <!-- https://postgis.net/docs/ST_Within.html --></p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_within</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div><p>Overlaps: <!-- https://postgis.net/docs/ST_Overlaps.html --></p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_overlaps</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div><p>Intersects: <!-- https://postgis.net/docs/ST_Intersects.html --></p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_intersects</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div><p>Disjoint: <!-- https://postgis.net/docs/ST_Disjoint.html --></p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_disjoint</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div><p>Touches: <!-- https://postgis.net/docs/ST_Touches.html --></p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_touches</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div><p>Crosses: <!-- https://postgis.net/docs/ST_Crosses.html --></p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_crosses</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div><p>DE9-IM - <a href="https://en.wikipedia.org/wiki/DE-9IM" class="uri">https://en.wikipedia.org/wiki/DE-9IM</a> <!-- https://edzer.github.io/sfr/reference/st_relate.html --></p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_relate</span>(a, b, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)</code></pre></div><!-- examples (points/polygons) --><!-- examples (points/lines) --><!-- examples (lines/polygons) --><!-- TODO? create a series of polygons distributed evenly over the surface of the Earth and clip them. --><!-- ```{r} --><!-- set.seed(2018) --><!-- blob_points = st_sample(x = world, size = 2) --><!-- blobs = st_buffer(x = blob_points, dist = 1) --><!-- plot(blobs) --></div><div id="modifying-geometry-data" class="section level2"><h2><span class="header-section-number">4.5</span> Modifying geometry data</h2><p>Spatial clipping is a form of spatial subsetting that involves changes to the <code>geometry</code> columns of at least some of the affected features.</p><p>Clipping can only apply to features more complex than points: lines, polygons and their ‘multi’ equivalents. To illustrate the concept we will start with a simple example: two overlapping circles with a centerpoint 1 unit away from each other and radius of 1:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b =<span class="st"> </span><span class="kw">st_sfc</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>)), <span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>))) <span class="co"># create 2 points</span>b =<span class="st"> </span><span class="kw">st_buffer</span>(b, <span class="dt">dist =</span> <span class="dv">1</span>) <span class="co"># convert points to circles</span>l =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>)<span class="kw">plot</span>(b)<span class="kw">text</span>(<span class="dt">x =</span> <span class="kw">c</span>(-<span class="fl">0.5</span>, <span class="fl">1.5</span>), <span class="dt">y =</span> <span class="dv">1</span>, <span class="dt">labels =</span> l) <span class="co"># add text</span></code></pre></div><div class="figure" style="text-align: center"><span id="fig:points"></span><img src="figures/points-1.png" alt="Overlapping circles." width="576" /><p class="caption">Figure 4.5: Overlapping circles.</p></div><p>Imagine you want to select not one circle or the other, but the space covered by both <code>x</code> <em>and</em> <code>y</code>. This can be done using the function <code>st_intersection()</code>, illustrated using objects named <code>x</code> and <code>y</code> which represent the left and right-hand circles:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x =<span class="st"> </span>b[<span class="dv">1</span>]y =<span class="st"> </span>b[<span class="dv">2</span>]x_and_y =<span class="st"> </span><span class="kw">st_intersection</span>(x, y)<span class="kw">plot</span>(b)<span class="kw">plot</span>(x_and_y, <span class="dt">col =</span> <span class="st">&quot;lightgrey&quot;</span>, <span class="dt">add =</span> <span class="ot">TRUE</span>) <span class="co"># color intersecting area</span></code></pre></div><p><img src="figures/unnamed-chunk-29-1.png" width="576" style="display: block; margin: auto;" /></p><p>The subsequent code chunk demonstrate how this works for all combinations of the ‘venn’ diagram representing <code>x</code> and <code>y</code>, inspired by <a href="http://r4ds.had.co.nz/transform.html#logical-operators">Figure 5.1</a> of the book R for Data Science <span class="citation">(Grolemund and Wickham <a href="#ref-grolemund_r_2016">2016</a>)</span>. <!-- Todo: reference r4ds --></p><div class="figure" style="text-align: center"><span id="fig:venn-clip"></span><img src="figures/venn-clip-1.png" alt="Spatial equivalents of logical operators" width="576" /><p class="caption">Figure 4.6: Spatial equivalents of logical operators</p></div><p>To illustrate the relationship between subsetting and clipping spatial data, we will subset points that cover the bounding box of the circles <code>x</code> and <code>y</code> in Figure <a href="spatial-data-operations.html#fig:venn-clip">4.6</a>. Some points will be inside just one circle, some will be inside both and some will be inside neither. To generate the points will use a function not yet covered in this book, <code>st_sample()</code>.</p><p>There are two different ways to subset points that fit into combinations of the circles: via clipping and logical operators. But first we must generate some points. We will use the <em>simple random</em> sampling strategy to sample from a box representing the extent of <code>x</code> and <code>y</code>, using the code below to generate the situation plotted in Figure <a href="spatial-data-operations.html#fig:venn-subset">4.7</a>:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bb =<span class="st"> </span><span class="kw">st_bbox</span>(<span class="kw">st_union</span>(x, y))pmat =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(bb[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">2</span>)]), <span class="dt">ncol =</span> <span class="dv">2</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)box =<span class="st"> </span><span class="kw">st_polygon</span>(<span class="kw">list</span>(pmat))<span class="kw">set.seed</span>(<span class="dv">2017</span>)p =<span class="st"> </span><span class="kw">st_sample</span>(<span class="dt">x =</span> box, <span class="dt">size =</span> <span class="dv">10</span>)<span class="kw">plot</span>(box)<span class="kw">plot</span>(x, <span class="dt">add =</span> T)<span class="kw">plot</span>(y, <span class="dt">add =</span> T)<span class="kw">plot</span>(p, <span class="dt">add =</span> T)<span class="kw">text</span>(<span class="dt">x =</span> <span class="kw">c</span>(-<span class="fl">0.5</span>, <span class="fl">1.5</span>), <span class="dt">y =</span> <span class="dv">1</span>, <span class="dt">labels =</span> l)</code></pre></div><div class="figure" style="text-align: center"><span id="fig:venn-subset"></span><img src="figures/venn-subset-1.png" alt="Randomly distributed points within the bounding box enclosing circles x and y." width="576" /><p class="caption">Figure 4.7: Randomly distributed points within the bounding box enclosing circles x and y.</p></div></div><div id="distance-relations" class="section level2"><h2><span class="header-section-number">4.6</span> Distance relations</h2><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_distance</span>(a, b)</code></pre></div></div><div id="spatial-operations-on-raster-data" class="section level2"><h2><span class="header-section-number">4.7</span> Spatial operations on raster data</h2><p>This section builds on <a href="attr.html#manipulating-raster-objects">3.3</a>, which highlights various basic methods for manipulating raster datasets, to demonstrate more advanced and explicitly spatial raster operations, and uses the same objects <code>r</code> and <code>r_2</code>.</p><div id="map-algebra-local-focal-zonal-global" class="section level3"><h3><span class="header-section-number">4.7.1</span> Map algebra: local, focal, zonal, global</h3><p>Raster processing is really fast because it only implicitly stores coordinates, that is we can calculate the coordinate of a raster cell due to its matrix position and the help of the resolution and the origin. For the processing, however, the geographic position of a cell is barely relevant as long as we make sure that the cell position is still the same after the processing (one-to-one locational correspondence). Additionally, if two or more raster datasets share the same extent, projection and the resolution, one could treat them as matrixes for the processing. This is exactly what map algebra is doing. First, it checks the headers of the rasters on which to perform any algebraic operation, and only if they correspondent to each other, the processing goes on. And secondly, map algebra retains the so-called one-to-one locational correspondence. This is where it substantially differs from matrix algebra which changes positions when for example multiplying or dividing matrixes.</p><p>Map algebra (or cartographic modeling) divides raster operations into four subclasses <span class="citation">(Tomlin <a href="#ref-tomlin_geographic_1990">1990</a>)</span>, with each of them either working on one or several grids simultaneously:</p><ol style="list-style-type: decimal"><li><em>Local</em> or per-cell operations.</li><li><em>Focal</em> or neighborhood operations. Most often the output cell value is the result of a 3 x 3 input cell block.</li><li><em>Zonal</em> operations are similar to focal operations but instead of a predefined neighborhood, classes, which can take on any, i.e. also an irregular size and shape, are the basis for calculations.</li><li><em>Global</em> or per-raster operations, that means the output cell derives its value potentially from one or several entire rasters</li></ol><p>This classification scheme uses basically the number of cells involved in a processing step as distinguishing feature. Of course, one can classify raster operations based on other characteristics such as discipline. Think, for instance, of terrain, hydrological analysis or image classifications. In the following paragraphs, we will explain each of the four map algebra operations by example.</p><p><strong>Local</strong> operations comprise all cell-by-cell operations in one or several layers. A good example is the classification of intervals of numeric values into groups such as grouping a digital elevation model into low (class 1), middle (class 2) and high elevations (class 3). Using the <code>reclassify()</code> command, we need first to construct a reclassification matrix, where the first column corresponds to the lower and the second column to the upper end of the class. The third column represents the new value for the specified ranges in column one and two. Here, we assign the raster values in the ranges 0–12, 12–24 and 24–36 are <em>reclassified</em> to take values 1, 2 and 3, respectively.</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rcl =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">12</span>, <span class="dv">1</span>, <span class="dv">12</span>, <span class="dv">24</span>, <span class="dv">2</span>, <span class="dv">24</span>, <span class="dv">36</span>, <span class="dv">3</span>), <span class="dt">ncol =</span> <span class="dv">3</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)recl =<span class="st"> </span><span class="kw">reclassify</span>(r, <span class="dt">rcl =</span> rcl)</code></pre></div><p>Raster algebra is another classical use case of local operations. This includes adding, subtracting and squaring two rasters. Raster algebra also allows logical operations such as finding all raster cells that are greater than a specific value (5 in our example below). The <strong>raster</strong> package allows all these operations in a way natural to R users. Please see the <code>Raster</code>-vignette for a more detailed description on algebraic operations (<code>vignette(&quot;Raster&quot;, package = &quot;raster&quot;)</code>).</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">r +<span class="st"> </span>rr^<span class="dv">2</span><span class="kw">log</span>(r)r &gt;<span class="st"> </span><span class="dv">5</span></code></pre></div><p>Instead of arithmetic operators, you can also use the <code>calc()</code> and <code>overlay()</code> functions. These functions are more efficient. So you should use them if you have to process large raster datasets. Additionally, they let you directly store an output file.</p><p>The calculation of the normalized difference vegetation index (NDVI) is one of the most famous local, i.e. pixel-by-pixel, raster operations. It ranges between - 1 and 1 with positive values indicating the presence of living plants (mostly &gt; 0.2). To calculate the NDVI, one uses the red and near-infrared bands of remotely sensed imagery (e.g., Landsat or Sentinel imagery) exploiting the fact that vegetation absorbs light heavily in the visible light spectrum, and especially in the red channel, while reflecting it in the near-infrared spectrum.</p><p><span class="math display">\[\begin{split}NDVI&amp;= \frac{\text{NIR} - \text{Red}}{\text{NIR} + \text{Red}}\\\end{split}\]</span> where NIR = near infrared channel Red = red channel</p><p>Predictive mapping is another interesting application of local raster operations. The response variable correspond to measured or observed points in space, for example, species richness, the presence of landslides, tree disease or crop yield. Consequently, we can easily retrieve space- or airborne predictor variables from various rasters (elevation, pH, precipitation, temperature, landcover, soil class, etc.). Subsequently, we model our response as a function of our predictors using <code>lm</code>, <code>glm</code>, <code>gam</code> or a machine-learning technique. To make a spatial prediction, all we have to do, is to apply the estimated coefficients to the predictor rasters, and summing up the resulting output rasters (<!--Chapter ??; -->see also <span class="citation">Muenchow et al. (<a href="#ref-muenchow_predictive_2013">2013</a>)</span>). <!-- add reference to chapter ecological modeling --></p><p>While local functions operate on one cell, though possibly from multiple layers, <strong>focal</strong> operations take into account a central cell and its neighbors. The neighborhood (also named kernel, filter or moving window) under consideration is typically of size 3-by-3 cells (that is the central cell and its eight surrounding neighbors) but can take on any other (not necessarily rectangular) shape as defined by the user. A focal operation applies an aggregation function to all cells within the specified neighborhood, uses the corresponding output as the new value for the the central cell, and moves on to the next central cell (Figure <a href="spatial-data-operations.html#fig:focal-example">4.8</a>). Other names for this operation are spatial filtering and convolution <span class="citation">(Burrough, McDonnell, and Lloyd <a href="#ref-burrough_principles_2015">2015</a>)</span>.</p><p>In R, we can use the <code>focal()</code> function to perform spatial filtering. We define the shape of the moving window with a <code>matrix</code> whose values correspond to weights. Secondly, the the <code>fun</code> argument lets us specify the function we wish to apply to this neighborhood. Here, we choose the minimum, but of course we can use any other function such as the the sum, the mean, the median, the mode, the maximum or the variance.</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">r_focal =<span class="st"> </span><span class="kw">focal</span>(r, <span class="dt">w =</span> <span class="kw">matrix</span>(<span class="dv">1</span>, <span class="dt">nrow =</span> <span class="dv">3</span>, <span class="dt">ncol =</span> <span class="dv">3</span>), <span class="dt">fun =</span> min)</code></pre></div><div class="figure" style="text-align: center"><span id="fig:focal-example"></span><img src="figures/03_focal_example.png" alt="Input raster (left) and resulting output raster (right) due to a focal operation - summing up 3-by-3 windows" width="475" /><p class="caption">Figure 4.8: Input raster (left) and resulting output raster (right) due to a focal operation - summing up 3-by-3 windows</p></div><p>We can quickly check if the output meets our expectations. In our example, the minimum value has to be always the upper left corner of the moving window (remember we have created the input raster by rowwise incrementing the cell values by one starting at the upper left corner). Of course, the <code>focal()</code>-function has computed the correct result. In this example, our weighting matrix consists only of 1s. This means each cell has the same weight on the output. If appropriate, you can change this by specifying different weights.</p><p>Focal functions or filters play a dominant role in image processing. Low-pass or smoothing filters use the mean function to remove extremes. In the case of categorical data, we can replace the mean with the mode, which is the most common value. By contrast, high-pass filters accentuate features. The line detection Laplace and Sobel filters might serve as an example here. Check the <code>focal()</code> help page how to use them in R.</p><p>Also, terrain processing uses heavily focal functions. Think, for instance, of the calculation of the slope, aspect and flow directions. The <code>terrain()</code> function lets you compute a few of these terrain characteristics but has not implemented all popular methods For example, the Zevenbergen and Thorne method to compute the slope is missing. Equally, many other terrain and GIS functions are <strong>not</strong> implemented in R such as curvatures, contributing areas, different wetness indexes, and many more. Fortunately, desktop GIS commonly provide these algorithms. In Chapter 13 we will learn how to access GIS functionality from within R. <!-- Reference 13-gis chapter --></p><p><em>Zonal</em> operations are similar to focal operations. The difference is that zonal filters can take on any shape instead of just a predefined window. Our grain size raster is a good example (Figure <a href="attr.html#fig:cont-cate-rasters">3.3</a>) because the different grain sizes are spread in an irregular fashion throughout the raster.</p><p>Now suppose, the first raster we created (<code>r</code>) represents elevation. To find the mean elevation for each grain size class, we can use the <code>zonal()</code> command. This kind of operation is also known as <em>zonal statistics</em> in the GIS world.</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">z =<span class="st"> </span><span class="kw">zonal</span>(r, r_2, <span class="dt">fun =</span> <span class="st">&quot;mean&quot;</span>) %&gt;%<span class="st">  </span>as.data.framez<span class="co">#&gt;   zone mean</span><span class="co">#&gt; 1    1 16.8</span><span class="co">#&gt; 2    2 19.4</span><span class="co">#&gt; 3    3 19.8</span></code></pre></div><p>This returns the statistics for each category, here the mean altitude for each grain size class. Of course, we can add this statistic to the attribute table of the ratified raster (remember RAT stands for raster attribute table, see also previous chapter).</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(r_2)[[<span class="dv">1</span>]] =<span class="st">  </span><span class="kw">cbind</span>(<span class="kw">levels</span>(r_2)[[<span class="dv">1</span>]], <span class="dt">mean_elev =</span> z$mean)</code></pre></div><p><em>Global</em> operations are a special case of zonal operations with the entire raster dataset representing a single zone. The most common global operations are descriptive statistics for the entire raster dataset such as the minimum or maximum (see previous chapter). Aside from that, global operations are also useful for the computation of distance and weight rasters. In the first case, one can calculate the distance from each cell to a specific target cell. For example, one might want to compute the distance to the nearest coast (see also <code>raster::distance()</code>). We might also want to consider topography, that means, we are not only interested in the pure distance but would like also to avoid the crossing of mountain ranges when going to the coast. To do so, we can weight the distance with elevation so that each additional altitudinal meter ‘prolongs’ the euclidean distance. Visibility and viewshed computations also belong to the family of global operations <!--(in the exercises of Chapter ?? you will compute a viewshed raster)-->. <!-- reference 13-gis chapter--></p></div><div id="mosaics" class="section level3"><h3><span class="header-section-number">4.7.2</span> Mosaics</h3></div><div id="raster-aggregation-disaggregation-and-resampling" class="section level3"><h3><span class="header-section-number">4.7.3</span> Raster aggregation, disaggregation and resampling</h3><!-- ## Spatial data creation --><!-- where should "area" example be? in this or the previous chapter? --><!-- Not here - I think this chapter should focus on geomtry data --><!-- `st_centroid()` --><!-- `st_buffer()` --><!-- http://r-spatial.org//r/2017/06/09/mapedit_0-2-0.html --><!-- Commented out - think this would be better in c3 (RL) --><!-- ```{r} --><!-- # add a new column --><!-- africa$area = set_units(st_area(africa), value = km^2) --><!-- africa$pop_density = africa$pop / africa$area --><!-- # OR --><!-- africa = africa %>% --><!--         mutate(area = set_units(st_area(.), value = km^2)) %>% --><!--         mutate(pop_density = pop / area) --><!-- ``` --><!-- Note that this has created a attributes for the area and population density variables: --><!-- ```{r} --><!-- attributes(africa$area) --><!-- attributes(africa$pop_density) --><!-- ``` --><!-- These can be set to `NULL` as follows: --><!-- ```{r} --><!-- attributes(africa$area) = NULL --><!-- attributes(africa$pop_density) = NULL --><!-- ``` --><!-- ## Spatial data transformation --><!-- changes classes; polygonize, etc--></div><div id="exercises-3" class="section level3"><h3><span class="header-section-number">4.7.4</span> Exercises</h3><ol style="list-style-type: decimal"><li>Write code that subsets points that are contained within <code>x</code> <em>and</em> <code>y</code> (illustrated by the plot in the 2<sup>nd</sup> row and the 1<sup>st</sup> column in Figure <a href="spatial-data-operations.html#fig:venn-clip">4.6</a>).</li></ol><ul><li>Create a randomly located point with the command <code>st_point()</code> (refer back to section <a href="spatial-class.html#sfg">2.1.4.2</a> to see how to create spatial data ‘from scratch’).</li></ul><ol start="2" style="list-style-type: decimal"><li>Write code that uses functions <code>aggregate()</code> and <code>st_buffer()</code> to answers the following question: What proportion of the world’s population lives in countries that intersect a circle with a 10 degree radius of the intersection between the equator and the <a href="https://en.wikipedia.org/wiki/9th_meridian_east">9<sup>th</sup> meridian</a>? (Advanced challenge: find the point with the highest number of people within a 10 degree radius.)</li></ol><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">center9 =<span class="st"> </span><span class="kw">st_sf</span>(<span class="kw">st_sfc</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(-<span class="dv">9</span>, <span class="dv">0</span>)), <span class="dt">crs =</span> <span class="dv">4326</span>))buff9 =<span class="st"> </span><span class="kw">st_buffer</span>(center9, <span class="dt">dist =</span> <span class="dv">10</span>)<span class="co">#&gt; Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs): st_buffer does</span><span class="co">#&gt; not correctly buffer longitude/latitude data, dist needs to be in decimal</span><span class="co">#&gt; degrees.</span>agg9 =<span class="st"> </span><span class="kw">aggregate</span>(world[<span class="st">&quot;pop&quot;</span>], buff9, <span class="dt">FUN =</span> sum)<span class="co">#&gt; although coordinates are longitude/latitude, it is assumed that they are planar</span>agg9$pop /<span class="st"> </span><span class="kw">sum</span>(world$pop, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)<span class="co">#&gt; [1] 0.00998</span></code></pre></div><ol start="3" style="list-style-type: decimal"><li>Assuming that people are evenly distributed across countries, estimate the population living <em>within</em> the circle created to answer the previous question.</li></ol><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">interp9 =<span class="st"> </span><span class="kw">st_interpolate_aw</span>(<span class="dt">x =</span> world[<span class="st">&quot;pop&quot;</span>], <span class="dt">to =</span> buff9, <span class="dt">extensive =</span> <span class="ot">TRUE</span>)<span class="co">#&gt; Warning in st_interpolate_aw(x = world[&quot;pop&quot;], to = buff9, extensive =</span><span class="co">#&gt; TRUE): st_interpolate_aw assumes attributes are constant over areas of x</span></code></pre></div><!-- Raster exercises--><ol start="4" style="list-style-type: decimal"><li>Use <code>data(dem, package = &quot;RQGIS&quot;)</code>, and reclassify the elevation in three classes: low, middle and high. Secondly, compute the NDVI (<code>data(ndvi, package = &quot;RQGIS&quot;)</code>) and the mean elevation for each altitudinal class.</li><li>Apply a line detection filter to <code>data(dem, package = &quot;RQGIS&quot;)</code>.</li><li>Calculate the NDVI of a Landsat image. Use the Landsat image provided by the <strong>spDataLarge</strong> package (<code>system.file(&quot;raster/landsat.tif&quot;, package=&quot;spDataLarge&quot;)</code>).</li><li>This <a href="https://stackoverflow.com/questions/35555709/global-raster-of-geographic-distances">post</a> shows how to use <code>raster::distance()</code>. Extract Spain, calculate a distance raster and weight it with elevation. Finally, compute the difference between the raster using the euclidean distance and the raster weighted by elevation. (Hint: Have a look at <code>getData()</code> to retrieve a digital elevation model for Spain.)</li></ol><!--chapter:end:04-spatial-operations.Rmd--></div></div></div><div id="read-write" class="section level1"><h1><span class="header-section-number">5</span> Geographic data I/O</h1><p>The previous chapters provided an overview of spatial data classes in R, with a focus on simple features and raster. This chapter is about getting spatial data onto your computer and then, perhaps after processing it with techniques described in this book, back out to the world. <!-- Not sure if this is the place for the following two sentences... Or if so, some kind of link is missing.--> We include a section (<a href="read-write.html#visual-outputs">5.4</a>) on visualization because outputting data in a human (not just computer) readable format enables non-programmers to benefit from your work. If your aim is to use geocomputation to improve the world, e.g. by encouraging evidence-based policies, this final stage is vital.</p><p>I/O is short for “input/output” which means, in plain English, “reading and writing data”. We use the acronym instead of plain English not to confuse you or to make chapter names short, but because that’s the term used in computer science and it is useful to think of data import and export from a computing perspective.<a href="references.html#fn24" class="footnoteRef" id="fnref24"><sup>24</sup></a></p><!-- Old intro to this chapter - can we salvage anything from this? --><!-- Reading, writing and plotting are 3 of the most important initial stages in geocomputation. --><!-- If you cannot load your data, it's not even worth starting. --><!-- If you cannot write your processed data, it will make it hard to collaborate with others. --><!-- Furthermore, an often-overlooked issue is that if you cannot create visuals of your spatial data, it will be hard to understand. --><!-- For this reason this introductory chapter also has a section on basic map making. --><div id="data-input-i" class="section level2"><h2><span class="header-section-number">5.1</span> Data Input (I)</h2><p>To efficiently read data into R, it helps to have an understanding of what happens ‘under the hood’. Executing commands such as <code>sf::st_read()</code> (the main function we use for loading vector data, from the <strong>sf</strong> package), <code>raster::raster()</code> (the main function used for loading raster data, from the <strong>raster</strong> package), or <code>readr::read_csv()</code> (which can we used to read spatial data from text files) silently sets off a chain of events that loads objects. “Loading” in this context means loading the data into R or, more precisely, assigning objects to your workspace, stored in RAM accessible from the <code>.GlobalEnv</code> of your current R session. <!-- What is your understanding of workspace? Or what is the difference between workspace and the global environment here?--> <!-- coud add a footnote here mentioning `.GlobalEnv` --></p><div id="vector-data-1" class="section level3"><h3><span class="header-section-number">5.1.1</span> Vector data</h3><p>Spatial vector data comes in a wide variety of file formats, and <strong>sf</strong> is able to handle most of them <!-- is that right? --> via its <code>st_read()</code> command. Behind the scenes it uses GDAL, which supports the import of a very wide range of vector data formats<a href="references.html#fn25" class="footnoteRef" id="fnref25"><sup>25</sup></a>. The first argument of <code>st_read()</code> is <code>file</code>, which should be a text string or an object containing a single text string:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(sf)<span class="co">#&gt; Linking to GEOS 3.5.0, GDAL 2.1.0, proj.4 4.8.0</span>vector_filepath =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;shapes/world.gpkg&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;spData&quot;</span>)world =<span class="st"> </span><span class="kw">st_read</span>(vector_filepath)<span class="co">#&gt; Reading layer `wrld.gpkg&#39; from data source `/home/travis/R/Library/spData/shapes/world.gpkg&#39; using driver `GPKG&#39;</span><span class="co">#&gt; Simple feature collection with 177 features and 10 fields</span><span class="co">#&gt; geometry type:  MULTIPOLYGON</span><span class="co">#&gt; dimension:      XY</span><span class="co">#&gt; bbox:           xmin: -180 ymin: -90 xmax: 180 ymax: 83.64513</span><span class="co">#&gt; epsg (SRID):    4326</span><span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span></code></pre></div><!-- isn't that confusing? --><p><strong>Tip</strong>: <code>read_sf()</code> and <code>write_sf()</code> can be used as easy-to-remember alternatives to <code>st_read()</code> and <code>st_write()</code>. Remember they hide information about the data source and overwrite existing data, though.</p><p>A major advantage of <strong>sf</strong> is that it is fast. To demonstrate this, we will use a function to compare <code>st_read()</code> with its <strong>sp</strong> equivalent, <code>rgdal::readOGR()</code>:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bench_read =<span class="st"> </span>function(file, n) {  m =<span class="st"> </span><span class="kw">microbenchmark</span>(<span class="dt">times =</span> n,                     rgdal::<span class="kw">readOGR</span>(vector_filepath),                     <span class="kw">st_read</span>(vector_filepath)  )  <span class="kw">mean</span>(m$time[<span class="dv">1</span>:n]) /<span class="st"> </span><span class="kw">mean</span>(m$time[(n +<span class="st"> </span><span class="dv">1</span>):(n *<span class="st"> </span><span class="dv">2</span>)])}</code></pre></div><p>This function takes as arguments an input file (<code>file</code>) and a number of times to run each command (<code>n</code>) and returns how many times faster <code>st_read()</code> is than <code>readOGR()</code>. Let’s run the benchmark for the <code>world.gpkg</code> file represented by the object <code>vector_filepath</code>:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(microbenchmark)read_world_gpkg =<span class="st"> </span><span class="kw">bench_read</span>(<span class="dt">file =</span> vector_filepath, <span class="dt">n =</span> <span class="dv">5</span>)</code></pre></div><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">read_world_gpkg<span class="co">#&gt; [1] 2.28</span></code></pre></div><p>The results demonstrate that <strong>sf</strong> was around 2 times faster than <strong>rgdal</strong> at reading-in the world countries vector. The relative performance of <code>st_read()</code> compared with other functions will vary depending on file format and the nature of the data. To illustrate this point, we performed the same operation on a geojson file and found a greater speed saving:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">vector_filepath_gj =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;shapes/cycle_hire_osm.geojson&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;spData&quot;</span>)read_lnd_geojson =<span class="st"> </span><span class="kw">bench_read</span>(<span class="dt">file =</span> vector_filepath_gj, <span class="dt">n =</span> <span class="dv">5</span>)</code></pre></div><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">read_lnd_geojson<span class="co">#&gt; [1] 3.66</span></code></pre></div><p>In this case <strong>sf</strong> was around 4 times faster than <strong>rgdal</strong>.</p><p>To find out which data formats <strong>sf</strong> supports, run <code>st_drivers()</code>. Here, we show only the first two drivers:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sf_drivers =<span class="st"> </span><span class="kw">st_drivers</span>()<span class="kw">head</span>(sf_drivers, <span class="dt">n =</span> <span class="dv">2</span>)<span class="co">#&gt;          name                  long_name write  copy is_raster is_vector</span><span class="co">#&gt; PCIDSK PCIDSK       PCIDSK Database File  TRUE FALSE      TRUE      TRUE</span><span class="co">#&gt; netCDF netCDF Network Common Data Format  TRUE  TRUE      TRUE      TRUE</span></code></pre></div><!-- temporal text subsection --><!-- data needs to be added to spData --><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cycle_hire1 =<span class="st"> </span><span class="kw">st_read</span>(<span class="st">&quot;cycle_hire_xy.csv&quot;</span>, <span class="dt">options =</span> <span class="kw">c</span>(<span class="st">&quot;X_POSSIBLE_NAMES=X&quot;</span>,                                                       <span class="st">&quot;Y_POSSIBLE_NAMES=Y&quot;</span>))cycle_hire2 =<span class="st"> </span><span class="kw">st_read</span>(<span class="st">&quot;cycle_hire_wkt.csv&quot;</span>, <span class="dt">options =</span> <span class="st">&quot;GEOM_POSSIBLE_NAMES=WKT&quot;</span>)</code></pre></div></div><div id="raster-data-1" class="section level3"><h3><span class="header-section-number">5.1.2</span> Raster data</h3><p>Raster data also could exist in many different file formats, with some of the formats supporting multilayer files.<a href="references.html#fn26" class="footnoteRef" id="fnref26"><sup>26</sup></a></p><p>The <strong>raster</strong> package support reading one layer by <code>raster()</code> and many layers using either <code>brick()</code> or <code>stack()</code>. More information about the raster representation in this package could be find in the section <a href="spatial-class.html#raster-classes">2.2.3</a>.</p><p>The <code>raster()</code> function makes it possible to read a simple single layer file:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(raster)<span class="co">#&gt; Loading required package: sp</span><span class="kw">library</span>(spDataLarge)raster_filepath =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;raster/srtm.tif&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;spDataLarge&quot;</span>)single_layer =<span class="st"> </span><span class="kw">raster</span>(raster_filepath)</code></pre></div><p>Or to read just one layer (band) from a multilayer file:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">raster_multilayer_filepath =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;raster/landsat.tif&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;spDataLarge&quot;</span>)single_layer_band3 =<span class="st"> </span><span class="kw">raster</span>(raster_multilayer_filepath, <span class="dt">band =</span> <span class="dv">3</span>)</code></pre></div><p>The whole multilayer raster file is read by <code>brick()</code>:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">multilayer_layer_brick =<span class="st"> </span><span class="kw">brick</span>(raster_multilayer_filepath)</code></pre></div><p>Finally, many single and multilayer files could be read in the same time with the <code>stack()</code> function:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">raster_l1_filepath =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;raster/landsat_b2.tif&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;spDataLarge&quot;</span>)raster_l2_filepath =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;raster/landsat_b3.tif&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;spDataLarge&quot;</span>) multilayer_layer_stack =<span class="st"> </span><span class="kw">stack</span>(raster_l1_filepath, raster_l2_filepath)</code></pre></div><p>The only limitation to <code>stack()</code> is that all datasets need to have the same spatial extent and resolution.</p><!-- NetCDF? --><!-- temporal text subsection --></div></div><div id="data-output-o" class="section level2"><h2><span class="header-section-number">5.2</span> Data output (O)</h2><!-- raster + vector + text intro --><div id="vector-data-2" class="section level3"><h3><span class="header-section-number">5.2.1</span> Vector data</h3><p>The counterpart of <code>st_read()</code> is <code>st_write()</code>. It allows to write <strong>sf</strong> objects to a wide range of geographic vector file formats, including the most common ones such as <code>.geojson</code>, <code>.shp</code> and <code>.gpkg</code>. Based on the file name <code>st_write()</code> decides automatically which driver to use. How fast the writing process is depends also on the driver: <!-- Is this comparison here necessary, or shouldn't we instead focus on the automatic driver selection? --></p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(<span class="kw">st_write</span>(world, <span class="st">&quot;world.geojson&quot;</span>, <span class="dt">quiet =</span> <span class="ot">TRUE</span>))<span class="co">#&gt;    user  system elapsed </span><span class="co">#&gt;   0.064   0.000   0.063</span><span class="kw">system.time</span>(<span class="kw">st_write</span>(world, <span class="st">&quot;world.shp&quot;</span>, <span class="dt">quiet =</span> <span class="ot">TRUE</span>)) <span class="co">#&gt;    user  system elapsed </span><span class="co">#&gt;   0.040   0.000   0.043</span><span class="kw">system.time</span>(<span class="kw">st_write</span>(world, <span class="st">&quot;world.gpkg&quot;</span>, <span class="dt">quiet =</span> <span class="ot">TRUE</span>))<span class="co">#&gt;    user  system elapsed </span><span class="co">#&gt;   0.020   0.012   0.030</span></code></pre></div><!-- ```{r} --><!-- st_write(obj = world, dsn = "world.gpkg") --><!-- ``` --><p><strong>Note</strong>: if you try to write to the same data source again, the function will fail. <!-- Why are you creating a modified version? Could you not use the same object again to demonstrate that overwriting will fail? --> This is demonstrated in the code below for a modified version of the world in which the population doubles in all countries (don’t worry about the <strong>dplyr</strong> code for now, this is covered in Chapter <a href="attr.html#attr">3</a>):</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world_mod =<span class="st"> </span>dplyr::<span class="kw">mutate</span>(world, <span class="dt">pop =</span> pop *<span class="st"> </span><span class="dv">2</span>)</code></pre></div><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_write</span>(<span class="dt">obj =</span> world_mod, <span class="dt">dsn =</span> <span class="st">&quot;world.gpkg&quot;</span>)##   GDAL Error 1: Layer world.gpkg already exists, CreateLayer failed.## Use the layer creation option OVERWRITE=YES to replace it.</code></pre></div><p>The error message (only partly reproduced above) provides some information as to why the function failed. The <code>GDAL Error 1</code> statement makes clear that the failure occurred at the GDAL level. Additionally, the suggestion to use <code>OVERWRITE=YES</code> provides a clue how to fix the problem. However, this is a GDAL option, and not a <code>st_write()</code> argument. Luckily, <code>st_write</code> provides a <code>layer_options</code> argument through which we can pass driver-dependent options:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_write</span>(<span class="dt">obj =</span> world_mod, <span class="dt">dsn =</span> <span class="st">&quot;world.gpkg&quot;</span>, <span class="dt">layer_options =</span> <span class="st">&quot;OVERWRITE=YES&quot;</span>)</code></pre></div><p>Another solution is to use the <code>st_write()</code> argument <code>delete_layer</code>. Setting it to <code>TRUE</code> deletes already existing layers in the data source before the function attempts to write (note there is also a <code>delete_dsn</code> argument):</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_write</span>(<span class="dt">obj =</span> world_mod, <span class="dt">dsn =</span> <span class="st">&quot;world.gpkg&quot;</span>, <span class="dt">delete_layer =</span> <span class="ot">TRUE</span>)</code></pre></div><p>You can achieve the same with <code>write_sf()</code> since it is equivalent to (technically an <em>alias</em> for) <code>st_write()</code>, except that its defaults for <code>delete_layer</code> and <code>quiet</code> is <code>TRUE</code>. This enables spatial data to be overwritten more concisely, and with less output going to screen: <!-- What does this mean: overwritten more concisely? --></p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">write_sf</span>(<span class="dt">obj =</span> world_mod, <span class="dt">dsn =</span> <span class="st">&quot;world.gpkg&quot;</span>)</code></pre></div><!-- Is the file.remove()-part important? --><p>A blunter way to update file-based geographic data sources such as <code>.gpkg</code> files is to simply delete them. This is not generally recommended, as it will not work for multi-file data sources such as <code>.shp</code> files:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">file.remove</span>(<span class="st">&quot;world.gpkg&quot;</span>)</code></pre></div><!-- temporal text subsection --><!-- saving sf POINT object as csv --><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(spData)<span class="kw">st_write</span>(cycle_hire, <span class="st">&quot;cycle_hire_xy.csv&quot;</span>, <span class="dt">layer_options =</span> <span class="st">&quot;GEOMETRY=AS_XY&quot;</span>)<span class="kw">st_write</span>(cycle_hire, <span class="st">&quot;cycle_hire_wkt.csv&quot;</span>, <span class="dt">layer_options =</span> <span class="st">&quot;GEOMETRY=AS_WKT&quot;</span>)</code></pre></div></div><div id="raster-data-2" class="section level3"><h3><span class="header-section-number">5.2.2</span> Raster data</h3><p>The <code>writeRaster()</code> function save the <code>Raster*</code> objects to files. There are several decision to be made while saving rasters, such as an output data type, file format, and specific GDAL options related to selected file format. The complete list of an arguments to this function could be found by typing <code>?writeRaster()</code>.</p><!-- datatypes --><p>The <strong>raster</strong> package offers nine following datatypes: LOG1S, INT1S, INT1U, INT2S, INT2U, INT4S, INT4U, FLT4S, and FLT8S. Datatype determines the type of numbers and the range of the raster values that would be written to disk. Decision which datatype should be used depends on the expected range of the values in the output file. For example, LOG1S is used for bitmap (binary) images, unsigned integers (INT1U, INT2U, INT4U) are mostly used for categorical data, while floats (FLT4S and FLTS8S) usually represent continuous data. The datatype used in <code>writeRaster()</code> is FLT4S. While it works in most of the cases, the size of the output file would be large. Therefore, a rule of thumb is to use the smallest representation that fits all the values (range of values could be checked using the <code>summary()</code> function). <!-- table? --></p><!-- file formats --><!-- options (geotiff) --><p>GeoTIFF is one of the most popular raster formats. Its structure is similar to the regular <code>.tif</code> format, however GeoTIFF also stores additional spatial metadata, such as coordinate reference system, spatial extent, <code>NoData</code> value, and the data resolution. You need to add the <code>.tif</code> file extention to save the raster object to a GeoTIFF file, for example:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">writeRaster</span>(<span class="dt">x =</span> single_layer,            <span class="dt">filename =</span> <span class="st">&quot;my_raster.tif&quot;</span>,            <span class="dt">datatype =</span> <span class="st">&quot;INT2U&quot;</span>)</code></pre></div><p>Some raster file formats also accept additional creation options<a href="references.html#fn27" class="footnoteRef" id="fnref27"><sup>27</sup></a>. For example, you could specify a compress method using the <code>COMPRESS</code> option:</p><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">writeRaster</span>(<span class="dt">x =</span> single_layer,            <span class="dt">filename =</span> <span class="st">&quot;my_raster.tif&quot;</span>,            <span class="dt">datatype =</span> <span class="st">&quot;INT2U&quot;</span>,            <span class="dt">options =</span> <span class="kw">c</span>(<span class="st">&quot;COMPRESS=DEFLATE&quot;</span>))</code></pre></div><p>Other raster file formats include <code>.grd</code>, <code>.nc</code>, <code>.asc</code>, and <code>.img</code>. Full list of the supported file format for writing <code>Raster*</code> objects could be found using <code>writeFormats().</code></p><!-- temporal text subsection --><!-- saving raster object as csv ?? - should be include that?--></div></div><div id="file-formats" class="section level2"><h2><span class="header-section-number">5.3</span> File formats</h2><div id="vector-formats" class="section level3"><h3><span class="header-section-number">5.3.1</span> Vector formats</h3><!-- 1. shp - (short history, was more or less an accident, a long-living makeshift arrangement) - don't use shp! --><!-- 2. gpkg - (maybe just mention here, gpkg since it is an SQLite 3 extension supporting both vector and raster formats) - reference to the "geodatabases" section --><!-- 3. wkt and wkb --><!-- 4. geojson - (web formats with a focus on geojson and here we can also mention kml, gml) --><!-- 5. maybe gpx - (maybe mention GPS formats such as GPX) --></div><div id="raster-formats" class="section level3"><h3><span class="header-section-number">5.3.2</span> Raster formats</h3><!-- 1. geotiff --><!-- 2. asc - (popular formats: asc (-> exported from ESRI)) --><!-- 3. JPEG - (possibly mention SAGA's sdat, Erdas Imagine) --><!-- 4. rasterfile - (raster's rasterfile (vignette("rasterfile"))) --><!-- 5. gpkg - (maybe just mention here, gpkg since it is an SQLite 3 extension supporting both vector and raster formats) - reference to the "geodatabases" section --><!-- 6. ncdf ? --></div><div id="geodatabases" class="section level3"><h3><span class="header-section-number">5.3.3</span> Geodatabases</h3><!--(can store vector and raster data)--><!-- 1. SQLite/SpatialLite + mention GRASS (uses SQLite) --><!-- 2. gpkg - explanation connected to the previous sections and to SQLite --><!-- 3. WKT/WKB for transfering and storing geometry data on databases. PostGIS (has even its own raster WKT (https://trac.osgeo.org/postgis/wiki/WKTRasterTutorial01); WKT also supported by Spatiallite, Oracle, MySQL, etc. (https://en.wikipedia.org/wiki/Well-known_text#RDBMS_Engines_that_provide_support) --><!-- 4. ESRI geodatabase, Oracle spatial database (mention + gdal support?) --></div></div><div id="visual-outputs" class="section level2"><h2><span class="header-section-number">5.4</span> Visual outputs</h2></div><div id="exercises-4" class="section level2"><h2><span class="header-section-number">5.5</span> Exercises</h2><ol style="list-style-type: decimal"><li><p>Name three differences between <code>write_sf()</code> and the more well-known function <code>st_write()</code>.</p></li><li><p>What are the default arguments of <code>read_sf()</code> and <code>write_sf()</code> that enable two of these differences?</p></li></ol><!-- ## Vector --><!-- - sf package - st_drivers- st_read, read_sf- st_write, write_sf- text files - WKT, WKB, sp (st_as_sf)--><!-- ## Raster --><!-- - raster package - raster--><!--chapter:end:05-read-write-plot.Rmd--></div></div><div id="references" class="section level1"><h1><span class="header-section-number">6</span> References</h1><!--chapter:end:references.Rmd--><div id="refs" class="references"><div><p>Akima, Hiroshi, and Albrecht Gebhardt. 2016. <em>Akima: Interpolation of Irregularly and Regularly Spaced Data</em>. <a href="https://CRAN.R-project.org/package=akima" class="uri">https://CRAN.R-project.org/package=akima</a>.</p></div><div><p>Appelhans, Tim, Florian Detsch, Christoph Reudenbach, and Stefan Woellauer. 2017. <em>Mapview: Interactive Viewing of Spatial Objects in R</em>. <a href="https://CRAN.R-project.org/package=mapview" class="uri">https://CRAN.R-project.org/package=mapview</a>.</p></div><div><p>Baddeley, Adrian, Ege Rubak, and Rolf Turner. 2015. <em>Spatial Point Patterns: Methodology and Applications with R</em>. London: Chapman; Hall/CRC Press. <a href="http://www.crcpress.com/Spatial-Point-Patterns-Methodology-and-Applications-with-R/Baddeley-Rubak-Turner/9781482210200/" class="uri">http://www.crcpress.com/Spatial-Point-Patterns-Methodology-and-Applications-with-R/Baddeley-Rubak-Turner/9781482210200/</a>.</p></div><div><p>Bivand, Roger. 2001. “More on Spatial Data Analysis.” <em>R News</em> 1 (3): 13–17.</p></div><div><p>———. 2003. “Approaches to Classes for Spatial Data in R.” In <em>Proceedings of DSC</em>, edited by Kurt Hornik, Friedrich Leisch, and Achim Zeileis. <a href="https://www.r-project.org/nosvn/conferences/DSC-2003/Proceedings/Bivand.pdf" class="uri">https://www.r-project.org/nosvn/conferences/DSC-2003/Proceedings/Bivand.pdf</a>.</p></div><div><p>———. 2016a. <em>Rgrass7: Interface Between GRASS 7 Geographical Information System and R</em>. <a href="https://CRAN.R-project.org/package=rgrass7" class="uri">https://CRAN.R-project.org/package=rgrass7</a>.</p></div><div><p>———. 2016b. <em>Spgrass6: Interface Between GRASS 6 and R</em>. <a href="http://CRAN.R-project.org/package=spgrass6" class="uri">http://CRAN.R-project.org/package=spgrass6</a>.</p></div><div><p>———. 2017. <em>Spdep: Spatial Dependence: Weighting Schemes, Statistics and Models</em>. <a href="https://CRAN.R-project.org/package=spdep" class="uri">https://CRAN.R-project.org/package=spdep</a>.</p></div><div><p>Bivand, Roger S. 2000. “Using the R Statistical Data Analysis Language on GRASS 5.0 GIS Database Files.” <em>Computers &amp; Geosciences</em> 26 (9): 1043–52. <a href="http://www.sciencedirect.com/science/article/pii/S0098300400000571" class="uri">http://www.sciencedirect.com/science/article/pii/S0098300400000571</a>.</p></div><div><p>Bivand, Roger, and Albrecht Gebhardt. 2000. “Implementing Functions for Spatial Statistical Analysis Using the Language.” <em>Journal of Geographical Systems</em> 2 (3): 307–17. <a href="http://www.springerlink.com/index/CJRPUMB78JUYH54W.pdf" class="uri">http://www.springerlink.com/index/CJRPUMB78JUYH54W.pdf</a>.</p></div><div><p>Bivand, Roger, and Nicholas Lewin-Koh. 2017. <em>Maptools: Tools for Reading and Handling Spatial Objects</em>. <a href="https://CRAN.R-project.org/package=maptools" class="uri">https://CRAN.R-project.org/package=maptools</a>.</p></div><div><p>Bivand, Roger, and Colin Rundel. 2017. <em>Rgeos: Interface to Geometry Engine - Open Source (GEOS)</em>. <a href="https://CRAN.R-project.org/package=rgeos" class="uri">https://CRAN.R-project.org/package=rgeos</a>.</p></div><div><p>Bivand, Roger, Tim Keitt, and Barry Rowlingson. 2017. <em>Rgdal: Bindings for the Geospatial Data Abstraction Library</em>. <a href="https://CRAN.R-project.org/package=rgdal" class="uri">https://CRAN.R-project.org/package=rgdal</a>.</p></div><div><p>Bivand, Roger, Edzer J Pebesma, and Virgilio Gómez-Rubio. 2013. <em>Applied Spatial Data Analysis with R</em>. Vol. 747248717. Springer.</p></div><div><p>Brenning, Alexander. 2012. <em>ArcGIS Geoprocessing in R via Python</em>. <a href="https://CRAN.R-project.org/package=RPyGeo" class="uri">https://CRAN.R-project.org/package=RPyGeo</a>.</p></div><div><p>Brenning, Alexander, and Donovan Bangs. 2016. <em>RSAGA: SAGA Geoprocessing and Terrain Analysis in R</em>. <a href="https://CRAN.R-project.org/package=RSAGA" class="uri">https://CRAN.R-project.org/package=RSAGA</a>.</p></div><div><p>Brzustowicz, Michael R. 2017. <em>Data Science with Java: [Practical Methods for Scientists and Engineers]</em>. First edition. Beijing Boston Farnham: O´Reilly.</p></div><div><p>Burrough, P. A., Rachael McDonnell, and Christopher D. Lloyd. 2015. <em>Principles of Geographical Information Systems</em>. Third edition. Oxford ; New York: Oxford University Press.</p></div><div><p>Calenge, C. 2006. “The Package Adehabitat for the R Software: Tool for the Analysis of Space and Habitat Use by Animals.” <em>Ecological Modelling</em> 197: 1035.</p></div><div><p>Chambers, John M. 2016. <em>Extending R</em>. CRC Press.</p></div><div><p>Cheng, Joe, Bhaskar Karambelkar, and Yihui Xie. 2017. <em>Leaflet: Create Interactive Web Maps with the JavaScript ’Leaflet’ Library</em>. <a href="https://CRAN.R-project.org/package=leaflet" class="uri">https://CRAN.R-project.org/package=leaflet</a>.</p></div><div><p>Garrard, Chris. 2016. <em>Geoprocessing With Python</em>. Shelter Island, NY: Manning Publications.</p></div><div><p>Gillespie, Colin, and Robin Lovelace. 2016. <em>Efficient R Programming: A Practical Guide to Smarter Programming</em>. O’Reilly Media. <a href="https://csgillespie.github.io/efficientR/" class="uri">https://csgillespie.github.io/efficientR/</a>.</p></div><div><p>Grolemund, Garrett, and Hadley Wickham. 2016. <em>R for Data Science</em>. 1 edition. O’Reilly Media.</p></div><div><p>Hijmans, Robert J. 2016a. <em>Geosphere: Spherical Trigonometry</em>. <a href="https://CRAN.R-project.org/package=geosphere" class="uri">https://CRAN.R-project.org/package=geosphere</a>.</p></div><div><p>———. 2016b. <em>Raster: Geographic Data Analysis and Modeling</em>. <a href="https://CRAN.R-project.org/package=raster" class="uri">https://CRAN.R-project.org/package=raster</a>.</p></div><div><p>Jr, Paulo J. Ribeiro, and Peter J. Diggle. 2016. <em>geoR: Analysis of Geostatistical Data</em>. <a href="https://CRAN.R-project.org/package=geoR" class="uri">https://CRAN.R-project.org/package=geoR</a>.</p></div><div><p>Kahle, David, and Hadley Wickham. 2013. “Ggmap: Spatial Visualization with Ggplot2.” <em>The R Journal</em> 5 (1): 144–61. <a href="http://journal.r-project.org/archive/2013-1/kahle-wickham.pdf" class="uri">http://journal.r-project.org/archive/2013-1/kahle-wickham.pdf</a>.</p></div><div><p>Lamigueiro, Óscar Perpiñán. 2014. <em>Displaying Time Series, Spatial, and Space-Time Data with R</em>. CRC Press.</p></div><div><p>Livingstone, David N. 1992. <em>The Geographical Tradition: Episodes in the History of a Contested Enterprise</em>. Oxford, UK ; Cambridge, USA: John Wiley &amp; Sons Ltd.</p></div><div><p>Longley, Paul. 2015. <em>Geographic Information Science &amp; Systems</em>. Fourth edition. Hoboken, NJ: Wiley.</p></div><div><p>Longley, Paul A., Sue M. Brooks, Rachael McDonnell, and Bill MacMillan, eds. 1998. <em>Geocomputation: A Primer</em>. 1 edition. Chichester, Eng. ; New York: Wiley.</p></div><div><p>Muenchow, Jannes, and Patrick Schratz. 2017. <em>RQGIS: Integrating R with QGIS</em>. <a href="https://CRAN.R-project.org/package=RQGIS" class="uri">https://CRAN.R-project.org/package=RQGIS</a>.</p></div><div><p>Muenchow, Jannes, Achim Bräuning, Eric Frank Rodríguez, and Henrik von Wehrden. 2013. “Predictive Mapping of Species Richness and Plant Species’ Distributions of a Peruvian Fog Oasis Along an Altitudinal Gradient.” <em>Biotropica</em> 45 (5): 557–66. doi:<a href="https://doi.org/10.1111/btp.12049">10.1111/btp.12049</a>.</p></div><div><p>Neteler, Markus, and Helena Mitasova. 2008. <em>Open Source GIS: A GRASS GIS Approach</em>. 3. ed. New York, NY: Springer.</p></div><div><p>Openshaw, Stan, and Robert J. Abrahart, eds. 2000. <em>Geocomputation</em>. 1 edition. London ; New York: CRC Press.</p></div><div><p>Pebesma, Edzer. 2017. <em>Sf: Simple Features for R</em>. <a href="https://github.com/r-spatial/sf/" class="uri">https://github.com/r-spatial/sf/</a>.</p></div><div><p>Pebesma, Edzer, and Roger Bivand. 2017. <em>Sp: Classes and Methods for Spatial Data</em>. <a href="https://CRAN.R-project.org/package=sp" class="uri">https://CRAN.R-project.org/package=sp</a>.</p></div><div><p>Pebesma, Edzer, and Benedikt Graeler. 2017. <em>Gstat: Spatial and Spatio-Temporal Geostatistical Modelling, Prediction and Simulation</em>. <a href="https://CRAN.R-project.org/package=gstat" class="uri">https://CRAN.R-project.org/package=gstat</a>.</p></div><div><p>Pebesma, Edzer, Thomas Mailund, and James Hiebert. 2016. “Measurement Units in R.” <em>The R Journal</em> 8 (2): 486–94. <a href="https://journal.r-project.org/archive/2016-2/pebesma-mailund-hiebert.pdf" class="uri">https://journal.r-project.org/archive/2016-2/pebesma-mailund-hiebert.pdf</a>.</p></div><div><p>Qiu, Fang, Caiyun Zhang, and Yuhong Zhou. 2012. “The Development of an Areal Interpolation ArcGIS Extension and a Comparative Study.” <em>GIScience &amp; Remote Sensing</em> 49 (5): 644–63. doi:<a href="https://doi.org/10.2747/1548-1603.49.5.644">10.2747/1548-1603.49.5.644</a>.</p></div><div><p>Ripley, Brian D. 2001. “Spatial Statistics in R.” <em>R News</em> 1 (2): 14–15.</p></div><div><p>Roller, D. 2010. <em>Eratosthenes’ “Geography”</em>. Princeton University Press. <a href="http://books.google.co.uk/books?id=8peKyWK_SWsC" class="uri">http://books.google.co.uk/books?id=8peKyWK_SWsC</a>.</p></div><div><p>Rowlingson, B. S, and P. J Diggle. 1993. “Splancs: Spatial Point Pattern Analysis Code in S-Plus.” <em>Computers &amp; Geosciences</em> 19 (5): 627–55. doi:<a href="https://doi.org/10.1016/0098-3004(93)90099-Q">10.1016/0098-3004(93)90099-Q</a>.</p></div><div><p>Rowlingson, Barry, and Peter Diggle. 2017. <em>Splancs: Spatial and Space-Time Point Pattern Analysis</em>. <a href="https://CRAN.R-project.org/package=splancs" class="uri">https://CRAN.R-project.org/package=splancs</a>.</p></div><div><p>Rowlingson, Barry, Adrian Baddeley, Rolf Turner, and Peter Diggle. 2003. “Rasp: A Package for Spatial Statistics.” In <em>Proceedings of the 3rd International Workshop on Distributed Statistical Computing</em>, edited by Kurt Hornik. <a href="https://www.r-project.org/conferences/DSC-2003/Proceedings/RowlingsonEtAl.pdf" class="uri">https://www.r-project.org/conferences/DSC-2003/Proceedings/RowlingsonEtAl.pdf</a>.</p></div><div><p>Tennekes, Martijn. 2017. <em>Tmap: Thematic Maps</em>. <a href="https://CRAN.R-project.org/package=tmap" class="uri">https://CRAN.R-project.org/package=tmap</a>.</p></div><div><p>Tobler, Waldo R. 1979. “Smooth Pycnophylactic Interpolation for Geographical Regions.” <em>Journal of the American Statistical Association</em> 74 (367): 519–30. doi:<a href="https://doi.org/10.1080/01621459.1979.10481647">10.1080/01621459.1979.10481647</a>.</p></div><div><p>Tomlin, C. Dana. 1990. <em>Geographic Information Systems and Cartographic Modeling</em>. Englewood Cliffs, N.J: Prentice Hall.</p></div><div><p>University, S. original by James J. Majure Iowa State, and R. port + extensions by Albrecht Gebhardt. 2016. <em>Sgeostat: An Object-Oriented Framework for Geostatistical Modeling in S+</em>. <a href="https://CRAN.R-project.org/package=sgeostat" class="uri">https://CRAN.R-project.org/package=sgeostat</a>.</p></div><div><p>Venables, W. N., and B. D. Ripley. 2002. <em>Modern Applied Statistics with S</em>. Fourth. New York: Springer. <a href="http://www.stats.ox.ac.uk/pub/MASS4" class="uri">http://www.stats.ox.ac.uk/pub/MASS4</a>.</p></div><div><p>Wickham, Hadley. 2014. <em>Advanced R</em>. CRC Press. <a href="http://www.crcpress.com/product/isbn/9781466586963 http://adv-r.had.co.nz http://www.crcpress.com/product/isbn/9781466586963 http://adv-r.had.co.nz" class="uri">http://www.crcpress.com/product/isbn/9781466586963 http://adv-r.had.co.nz http://www.crcpress.com/product/isbn/9781466586963 http://adv-r.had.co.nz</a>.</p></div><div><p>Wulf, Andrea. 2015. <em>The Invention of Nature: Alexander von Humboldt’s New World</em>. First American Edition. New York: Alfred A. Knopf.</p></div></div></div><div class="footnotes"><hr /><ol><li id="fn1"><p>The conference took place at the University of Leeds, where one of the authors (Robin) is currently based and where the 21<sup>st</sup> GeoComputation was hosted in 2017 (see <a href="http://www.geocomputation.org/">geocomputation.org</a>).<a href="intro.html#fnref1">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="attr.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="read-write.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/Robinlovelace/geocompr/edit/master/04-spatial-operations.Rmd",
"text": "Edit"
},
"download": null,
"toc": {
"collapse": "section"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
