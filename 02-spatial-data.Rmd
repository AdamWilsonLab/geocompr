# Geographic data in R {#spatial-class}

## Prerequisites {-}

This is the first practical chapter of the book, and therefore it comes with some software requirements.
We assume that you have installed on your computer a recent version of R and that you are comfortable using it at the command line, e.g., via an integrated development environment (IDE) such as RStudio (recommended).
R/RStudio works on all major operating systems.
You can install and set up both in a few minutes on most modern computers, as described in [section 2.3](https://csgillespie.github.io/efficientR/set-up.html#r-version) and [section 2.5](https://csgillespie.github.io/efficientR/set-up.html#rstudio) of @gillespie_efficient_2016 (other guides are available).

If you are not a regular R user, we recommend that you familiarize yourself with the language before proceeding with this chapter.
You can do so using resources such as @gillespie_efficient_2016, @grolemund_r_2016 as well as online interactive guides such as [DataCamp](https://www.datacamp.com/courses/free-introduction-to-r).
It is also worth to spend time to establish an efficient programming workflow, for example with the help of an RStudio '[project](https://csgillespie.github.io/efficientR/set-up.html#project-management)'.
Subsequently, you can use the RStudio project provided in the root directory of the [`geocompr`](https://github.com/Robinlovelace/geocompr) GitHub repository.
This will make it easier to run this book's worked examples on your computer.

* * *

After having successfully installed R, you have to install and load add-on packages to handle spatial data.
On Mac and Linux operating systems there are a few additional requirements: see the [README](https://github.com/r-spatial/sf) of the **sf** package for instructions.
The **sf**, **raster**, and **spData** packages used in this chapter can be installed and loaded with the following commands:

```{r, eval=FALSE}
install.packages("sf")
install.packages("raster")
install.packages("spData")
library(sf)
library(raster)
library(spData)
```

This chapter will provide brief explanations of the fundamental geographic data models: vector and raster.
We will introduce briefly the theory behind both data models, and then move quickly towards how these are implemented in R.
Vector and raster models are vital to geospatial analysis [@longley_geographic_2015].
The vector data model represents the world using points, lines and polygons.
Hence, it supports data with discrete, well-defined borders.
On the other hand, the raster data model is good at representing continous phenomena such as elevation or rainfall with the help of grid cells.
Naturally, it depends on your discipline if you more often user raster or vector data:

- Vector data tends to dominate the social sciences because human settlements and boundaries have discrete borders.
- By contrast, raster data often dominates the environmental sciences because these often use remotely sensed imagery. 

However, there is a substantial level of overlap:
ecologists and demographers, for example, commonly use both vector and raster data.
We, therefore, strongly recommend learning about each data model before proceeding to understand how to manipulate them in subsequent chapters.

## Vector data

Vector data are based on points that are located on a Cartesian (or geographic) coordinate system.
Typically, a point consists of an x and a y value. 
These two numbers simply represent the distance from the $origin$ along the $x$ (horizontal) and $y$ (vertical) axis in Euclidean space.^[In 3 dimensional coordinate systems three numbers are needed for each of the three axes, $x$, $y$ and $z$.]
In mathematical notation these points are typically represented as numbers separated by commas and enclosed by a pair of brackets: 
$(1, 3)$ for example, represents a point located one unit to the right and three units above the origin.
There is a clear link between these vector points and the `vector` class in R.
The following line of code, for example, creates a 2 dimensional vector:

```{r}
p = vector(mode = "numeric", length = 2)
```

More commonly one would read-in data with functions such as `read_csv()` from the **tidyverse** or `read_sf()` from the **sf** package, covered in chapter \@ref(read-write).
To generate new data (e.g. for testing), one would more commonly use the command `c()` (think of 'c' for 'combine'), as illustrated
below:^[Other methods for generating numbers include with the `seq()` function (short for 'sequence') for generating regular sequences or `runif()`, `rnorm()` and other functions generating random numbers following some kind of probability distribution.
The **mapedit** package can be used to create spatial data manually on an interactive map.
]

```{r}
p = c(1, 3)
```

Now this can be plotted in Cartesian space, as illustrated in figure \@ref(fig:cartesian):

```{r cartesian, fig.cap="Illustration of vector point data in base R."}
plot(p[1], p[2], xlim =  c(0, 5), ylim = c(0, 5))
```

Generally vector datasets have a high level of precision (but not necessarily accuracy as we will see in \@ref(units)).
Raster datasets, by contrast, use cells that break the surface up into a cells of constant size (*resolution*). Rasters therefore aggregate spatially specific features to a given resolution resulting in small features being blurred or lost in raster datasets.
<!-- todo: add figure(s) showing raster data and blurring? -->
This book uses **sf** and **raster** packages to work with vector data and raster datasets respectively.

### An introduction to simple features {#intro-sf}

Simple features is an open standard developed and endorsed by the Open Geospatial Consortium ([OGC](http://portal.opengeospatial.org/files/?artifact_id=25355)) to represent a wide range of geographical information.
It is a hierarchical data model that simplifies geographic data by condensing a complex range of geographic forms into a single geometry class.
Only 7 out of 68 possible types of simple feature are currently used in the vast majority of GIS operations (Figure \@ref(fig:sf-ogc)).
The R package **sf** [@R-sf] fully supports all of these (including plotting methods etc.).^[
The full OGC standard includes rather exotic geometry types including 'surface' and 'curve' geometry types, which currently have limited application in real world applications.
All 68 types can be represented in R, although (at the time of writing) all methods, such as plotting, are only supported for the 7 types that are used.
]

```{r sf-ogc, fig.cap="The subset of the Simple Features class hierarchy supported by sf. Figure based on the Open Geospatial Consortium document [06-103r4](http://www.opengeospatial.org/standards/sfa).", out.width="100%", echo=FALSE}
knitr::include_graphics("figures/sf-classes.png")
```

**sf** can represent all common vector geometry types (raster data classes are not supported by **sf**): points, lines, polygons and their respective 'multi' versions (which group together features of the same type into a single feature).
**sf** also supports geometry collections, which can contain multiple geometry types in a single object.
Given the breadth of geographic data forms, it may come as a surprise that a class system to support all of them is provided in a single package, which can be installed from CRAN:^[The
development version, which may contain new features, can be installed with `devtools::install_github("r-spatial/sf").`
]
**sf** incorporates the functionality of the three main packages of the **sp** paradigm (**sp** [@R-sp] for the class system, **rgdal** [@R-rgdal] for reading and writing data, **rgeos** [@R-rgeos] for spatial operations undertaken by GEOS) in a single, cohesive whole.
This is well-documented in **sf**'s [vignettes](http://cran.rstudio.com/package=sf):

```{r, eval=FALSE}
vignette("sf1") # for an introduction to the package
vignette("sf2") # for reading, writing and converting Simple Features
vignette("sf3") # for manipulating Simple Features
```

As the first vignette explains, simple feature objects in R are stored in a data frame, with geographic data occupying a special column, a 'list-column'. This column is usually named 'geom' or 'geometry'.
Let us load a 'real world' example, here the `world` dataset, with the help of the **spData** package:

```{r, results='hide'}
library(spData)
```

**spData** silently loaded the `world` dataset (and many other spatial datasets - see [the spData website](https://nowosad.github.io/spData/) for a full list).
This dataset contains spatial and non-spatial information, as shown by the function `names()`, which reports the column headings in data frames. 
Please note that the last column contains the geographic information:

```{r}
names(world)
```

It is the contents of this modest-looking `geom` column that gives `sf` objects their spatial powers.
This so-called list-column contains all the coordinates.
**sf**'s `plot()` method uses these coordinates to create a map (Figure \@ref(fig:world-all)).

```{r world-all, fig.cap="A spatial plot of the world using the sf package, with a facet for each attribute."}
library(sf) # must be loaded to plot sf objects
plot(world)
```

Note that instead of creating a single map, as most GIS programs would, the `plot()` command has created multiple maps, one for each variable in the `world` datasets.
This behavior can be useful for exploring the spatial distribution of different variables and is discussed further in \@ref(basic-map) below.

Being able to treat spatial objects as regular data frames with spatial powers has many advantages, especially if you are already used to working with data frames.
The commonly used `summary()` function, for example, provides a useful overview of the variables within the `world` object.

```{r}
summary(world["lifeExp"])
```

Although we have only selected one variable for the `summary` command, it also outputs an report on the geometry (we explore such 'attribute operations' in more depth in Chapter \@ref(attr)).
This is due to the sticky behavior of the geometry columns of **sf** objects (see Chapter \@ref(attr)).
Hence, the result provides a quick summary of both the non-spatial and spatial data contained in `world`: the average life expectancy is 73 years (ranging from less than 50 to more than 80 years) across all countries which are represented in the form of `MULTIPOLYGON`s.
`MULTIPOLYGON`s allow more than one polygon per row (here: country).
This representation is necessary for countries with many islands such as Indonesia and Greece. 

<!-- TODO: cross-reference section covering CRSs. -->
It is worth taking a deeper look at the basic behavior and contents of this simple feature object, which can usefully be thought of as a '**S**patial data**F**rame).

`sf` objects are easy to subset.
The code below shows its first two rows and three columns.
The output shows two major differences compared with a regular `data.frame`: the inclusion of additional geographic data (`geometry type`, `dimension`, `bbox` and CRS information - `epsg (SRID)`, `proj4string`), and the presence of final `geometry` column:

```{r}
world[1:2, 1:3]
```

All this may seem rather complex, especially for a class system that is supposed to be simple.
However, there are good reasons for organizing things this way and using **sf**.

<!-- It's a `MULTIPOLYGON` with 177 features and a geographical (longitude/latidue) coordinate reference system (CRS) with an EPSG code of `4326`. -->

### Why Simple Features?

There are many advantages of **sf** over **sp**, including:

- Faster reading and writing of data (more than 10 times faster in some cases)
- Better plotting performance
- **sf** objects can be treated as dataframes in most operations
- **sf** functions can be combined using `%>%` operator and works well with the [tidyverse](http://tidyverse.org/) collection of R packages
- **sf** function names are relatively consistent and intuitive (all begin with `st_`) compared with the function names and syntax of the **sp**, **rgdal** and **rgeos** packages that it supersedes.

A broader advantage is that simple features are so well-supported by other software products, not least PostGIS, which has heavily influenced the design of **sf**.

A disadvantage you should be aware of, however, is that **sf** is not *feature complete* and that it continues to evolve.
The transition from **sp** to **sf** will likely take many years, and many spatial packages may never switch.
Even if you discover spatial data with R through the **sf** package, it is still worth at least being aware of **sp** classes, even if you rarely use them for everyday geospatial tasks.

Fortunately it is easy to translate between **sp** and **sf** using the `as()` function: 

```{r, eval=FALSE}
library(sp)
world_sp = as(object = world, Class = "Spatial")
```

@bivand_applied_2013 provides an excellent introduction to **sp**.

### Basic map making {#basic-map}

You can quickly create basic maps in **sf** with the base `plot()` function. By default, **sf** creates a multi-panel plot (like **sp**'s `spplot()`), one sub-plot for each variable (see left-hand image in Figure \@ref(fig:sfplot)). 

```{r sfplot, fig.cap="Plotting with sf, with multiple variables (left) and a single variable (right).", out.width="49%", fig.show='hold', warning=FALSE}
plot(world[3:4])
plot(world["pop"])
```

As with **sp**, you can add further layers to your maps using the `add = TRUE`-argument of the `plot()` function .^[In
fact, when you `plot()` an **sf** object, R is calling `sf:::plot.sf()` behind the scenes.
`plot()` is a generic method that behaves differently depending on the class of object being plotted.]
To illustrate this, and prepare for content covered in chapters \@ref(attr) and \@ref(spatial-data-operations) on attribute and spatial data operations, we will subset and combine countries in the `world` object, which creates a single object representing Asia:

```{r, warning=FALSE}
asia = world[world$continent == "Asia", ]
asia = st_union(asia)
```

We can now plot the Asian continent over a map of the world.
Note, however, that this only works if the initial plot has only one layer:

```{r asia, out.width='50%'}
plot(world["pop"])
plot(asia, add = TRUE, col = "red")
```

This can be very useful for quickly checking the geographic correspondence between two or more layers: 
the `plot()` function is fast to execute and requires few lines of code, but does not create interactive maps with a wide range of options.
For more advanced map making we recommend using a dedicated visualization package such as **tmap**, **ggplot2**, **mapview**, or **leaflet**.
<!-- TODO: cross reference advanced mapping chapter -->

<!-- 
- plot() function 
- map export 
-->

<!-- Maybe show also somewhere that `world[0]` produces only a plot of the geometry which is rather useful if you do not want to plot a specific attribute. This way, you can for example dismiss the col = "white"-argument in your Nigeria example.
Sorry for commenting on this again but just to clarify africa[0] selects zero columns but since the geometry column is sticky it won't be dismissed. Neverthess, to be more explicit one should probably use plot(st_geometry(africa))-->

```{r, eval=FALSE, echo=FALSE}
plot(africa[0], lwd = 3, main = "Nigeria in context", border = "lightgrey")
```

#### Further work

**sf** makes R data objects more closely aligned to the data model used in GDAL and GEOS, in theory making spatial data operations faster <!--I am not sure what you mean-->.
The work here provides a taste of the way **sf** operates but there is much more to learn (see Chapter \@ref(spatial-data-operations)).
And there is also a wealth of information in the highly recommended vignettes of the package.

As a final exercise, we will see one way of how to do a spatial overlay in **sf**.
First, we convert the countries of the world into centroids, and then subset those in Asia. Finally, the `summary`-command tells us how many centroids (countries) are part of Asia (43) and how many are not (134).

```{r}
world_centroids = st_centroid(world)
sel_asia = st_intersects(world_centroids, asia, sparse = FALSE)
summary(sel_asia)
```

<!--Note: another way of achieving the same result is with a GEOS function for identifying spatial overlay, which we will cover in more detail in Chapter \@ref(spatial-data-operations).-->

Since **sf**'s `plot()` function builds on base plotting methods, you may also use its many optional arguments (see `?plot` and `?par`).
This provides powerful but not necessarily intuitive functionality.
For instance, in order to make the diameter of a circle proportional to a country's population, we provide the `cex` argument with the result of a calculation (see Figure \@ref(fig:africa), and the code below).

```{r africa, fig.cap="Centroids representing country population, diameter being proportional to population.", warning=FALSE}
plot(world["continent"])
plot(world_centroids, add = TRUE, cex = world$pop / 1e8, lwd = 3)
```

<!-- More appropriate for subsequent chapters. -->
<!-- This shows that there are 43 countries in Asia -->
<!-- We can check if they are the same countries as follows: -->

<!-- ```{r} -->
<!-- africa_centroids2 = world_centroids[sel_africa,] -->
<!-- identical(africa_centroids, africa_centroids2) -->
<!-- ``` -->

### Simple feature classes {#sf_classes}

To understand new data formats in depth, it often helps to generate them for first principles.
This section walks through vector spatial classes step-by-step, from the elementary simple feature geometry to simple feature objects of class `sf` representing complex spatial data.
Before describing each geometry type that the **sf** package supports, it is worth taking a step back to understand the building blocks of `sf` objects. 
As stated in section \@ref(intro-sf), simple features are simply data frames with at least one special column that makes it spatial.
These spatial columns are often called `geom` or `geometry` and can be like non-spatial columns: `world$geom` refers to the spatial element of the `world` object described above.
These geometry columns are 'list columns' of class `sfc`: they are simple feature collections.
In turn, `sfc` objects are composed of one or more objects of class `sfg`: simple feature geometries.

To understand how the spatial components of simple features work, it is vital to understand simple feature geometries.
For this reason we cover each currently supported `sfg` type in the next subsections before moving on to describe how these can be combined to form `sfc` and eventually full `sf` objects.

#### Simple feature geometry types {#geometry}

<!-- This section demonstrates how the full range of geometry types supported by the **sf** package can be created, combined and plotted. -->
Geometries are the basic building blocks of simple features.
Simple features in R can take on one of the 17 geometry types supported by the **sf** package.
In this chapter we will focus on the seven most commonly used types: `POINT`, `LINESTRING`, `POLYGON`, `MULTIPOINT`, `MULTILINESTRING`, `MULTIPOLYGON` and `GEOMETRYCOLLECTION`.<!--FIG-->
Find the whole list of possible feature types in [the PostGIS manual ](http://postgis.net/docs/using_postgis_dbmanagement.html).

Generally, well-known binary (WKB) or well-known text (WKT) are the standard encoding for simple feature geometries.
WKB representations are usually hexadecimal strings easible readable for computers.
This is why, GIS and spatial databases use WKB to transfer and store geometry objects.
WKT, on the other hand, is a human-readable text markup description of simple features. 
Both formats are exchangeable, and if we present one, we will naturally choose the WKT representation.

The basis for each of the geometry types is the point. 
A point is simply a coordinate in 2D, 3D or 4D space:

- X and Y coordinates represent the location of the points on the surface of the Earth. Depending on the coordinate reference system you use, this can be, for example, easting and northing or longitude and latitude.
- Additionally, a Z coordinate might denote altitude but be aware of the fact that this representation is only a crude 3D-approximation.
The ability of a GIS and R to handle true volumes and surfaces is still limited.
- An M coordinate ("measure") allows to represent some measure associated to the point, but not the whole feature. 
This coordinate could be a time of measurement, information on who has measured the point or what is the error of measurement.

As a result, four possible types of points exist - XY (two-dimensional), XYZ (three-dimensional containing altitude), XYM (three-dimensional containing measure) and XYZM (four-dimensional).
They could be easily describes as a well-known text:

- XY - `POINT (5 2)`
- XYZ - `POINT (5 2 3)`
- XYM - `POINTM (5 2 1)`
- XYZM - `POINT (5 2 3 1)`

```{r point, echo=FALSE}
plot(st_as_sfc(c("POINT(5 2)")), axes = TRUE, main = "POINT")
```

A linestring is represented by a sequence of points with linear interpolation between points, for example:

- `LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)`

```{r linestring, echo=FALSE}
plot(st_as_sfc("LINESTRING(1 5, 4 4, 4 1, 2 2, 3 2)"), axes = TRUE, main = "LINESTRING")
```

Linestring cannot have self intersecting line part.
In other words, lines shouldn't pass through the same point twice (except for the endpoint).

A polygon is a sequence of points, where the first and last point have the same coordinates. 
Similarly to linestring, polygon needs to create a non-self intersecting ring.
By the definition, polygon has one exterior boundary (outer ring) and zero or more interior boundaries (inner ring).
These interior boundaries are often known as holes.

- Zero interior boundaries (holes) - `POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))`

```{r polygon, echo=FALSE}
plot(st_as_sfc("POLYGON((1 5, 2 2, 4 1, 4 4, 1 5))"), col="gray", axes = TRUE, main = "POLYGON")
```

- One hole - `POLYGON ((1 5, 4 4, 4 1, 2 2, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))`

```{r polygon_hole, echo=FALSE}
plot(st_as_sfc("POLYGON((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))"), col="gray", axes = TRUE, main = "POLYGON with a hole")
```

The next three geometry types are the sets of previous ones: a multipoint is a set of points, multilinestring is a set strings and multipolygon is a set of polygons:

- Multipoint - `MULTIPOINT (5 2, 1 3, 3 4, 3 2)`
- Multistring - `MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))`
- Multipolygon - `MULTIPOLYGON ((1 5, 4 4, 4 1, 2 2, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2))`

```{r multis, echo=FALSE}
par(mfrow = c(1, 3))
plot(st_as_sfc("MULTIPOINT (5 2, 1 3, 3 4, 3 2)"), axes = TRUE, main = "MULTIPOINT")
plot(st_as_sfc("MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))"), axes = TRUE, main = "MULTILINESTRING")
plot(st_as_sfc("MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 0 3, 1 3, 1 2, 0 2)))"), col="gray", axes = TRUE, main = "MULTIPOLYGON")
par(mfrow = c(1, 1))
```

A geometry collection is the most heterogeneous type.
It could consists of a set of any geometry types previously mentioned, for example:

- Geometry collection - `GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)))`

```{r geom_collection, echo=FALSE}
plot(st_as_sfc("GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)))"),
     axes = TRUE, main = "GEOMETRYCOLLECTION")
```

#### Simple feature geometry (sfg) objects {#sfg}

Simple feature geometry types are represented in R by objects of a `sfg` class. 
A `sfg` object is a geometry of a single feature - a point, linestring, polygon, multipoint, multilinestring, multipolygon or geometry collection.

Usually you don't need to create geometries on your own. 
In most cases, geometries are read from spatial files.
However, a set of function to create simple feature geometry objects (`sfg`) exists in R and could be used in special cases.
The names of these functions are simple and consistent, as they start with a `st_`  prefix and end with name of geometry types in lowercase letters:

- A point - `st_point()`
- A linestring - `st_linestring()`
- A polygon - `st_polygon()`
- A multipoint - `st_multipoint()`
- A multilinestring - `st_multilinestring()`
- A multipolygon - `st_multipolygon()`
- A geometry collection - `st_geometrycollection()`

In R, `sfg` objects are represented by three native data types:

1. A numeric vector - a single point
2. A matrix - a set of points, where each row contains a point - a multipoint or linestring
3. A list - any other set, e.g. a multilinestring or geometry collection

To create point objects, we could use the `st_point()` function:

```{r}
# note that we use a numeric vector for points
st_point(c(5, 2)) # XY point
st_point(c(5, 2, 3)) # XYZ point
st_point(c(5, 2, 1), dim = "XYM") # XYM point
st_point(c(5, 2, 3, 1)) # XYZM point
```

XY, XYZ and XYZM types of points are automatically created based on the length of a numeric vector. 
Only the XYM type needs to be specified using a `dim` argument.

Multipoint and linestring objects are created based on a matrix using `st_multipoint()` and `st_linestring()` functions:

```{r}
# the rbind function simplify creation of matrices
## MULTIPOINT
multipoint_matrix = rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))
st_multipoint(multipoint_matrix)

## LINESTRING
linestring_matrix = rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2))
st_linestring(linestring_matrix)
```

The rest of objects are represented by lists:

```{r}
## POLYGON
polygon_list = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))
st_polygon(polygon_list)
```

```{r}
## POLYGON with a hole
polygon_border = rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))
polygon_hole = rbind(c(2, 4), c(3, 4), c(3, 3), c(2, 3), c(2, 4))
polygon_with_hole_list = list(polygon_border, polygon_hole)
st_polygon(polygon_with_hole_list)
```

```{r}
## MULTILINESTRING
multilinestring_list = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), 
                            rbind(c(1, 2), c(2, 4)))
st_multilinestring((multilinestring_list))
```

```{r}
## MULTIPOLYGON
multipolygon_list = list(list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))),
                         list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2))))
st_multipolygon(multipolygon_list)
```

```{r}
## GEMETRYCOLLECTION
gemetrycollection_list = list(st_multipoint(multipoint_matrix),
                              st_linestring(linestring_matrix))
st_geometrycollection(gemetrycollection_list)
```

<!-- table -->
<!-- figure - image/fig1.jpg -->
<!-- they are interconnected - points could create mulitpoints or lines; -->
<!-- lines could create mutlilines or polygons, etc. -->
<!-- https://r-spatial.github.io/sf/articles/sf1.html -->

#### Simple feature collections {#sfc}

One `sfg` object contains only a single simple feature geometry. 
A simple feature collection (`sfc`) is a list of `sfg` objects with information about a coordinate reference system.
The `st_sfc()` function can be used to create `sfc` objects, as illustrated in the code below, which combines two simple features of a point type into a single feature:

```{r}
# sfc POINT
point1 = st_point(c(5, 2))
point2 = st_point(c(1, 3))
st_sfc(point1, point2)
```

In most cases, an `sfc` object contains objects of identical geometry type.
Therefore, when we combine `sfg` objects of a polygon type we would get `sfc` of a polygon type, and a collection of multilinestring would result into `sfc` of a multilinestring type:

```{r}
# sfc POLYGON
polygon_list1 = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))
polygon1 = st_polygon(polygon_list)
polygon_list2 = list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2)))
polygon2 = st_polygon(polygon_list2)
st_sfc(polygon1, polygon2)
```

```{r}
# sfc MULTILINESTRING
multilinestring_list1 = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), 
                            rbind(c(1, 2), c(2, 4)))
multilinestring1 = st_multilinestring((multilinestring_list1))
multilinestring_list2 = list(rbind(c(2, 9), c(7, 9), c(5, 6), c(4, 7), c(2, 7)), 
                            rbind(c(1, 7), c(3, 8)))
multilinestring2 = st_multilinestring((multilinestring_list2))
st_sfc(multilinestring1, multilinestring2)
```

It is possible to create a `sfc` object from `sfg` objects with different geometry types.
This new object would have a "geometry" geometry type:

```{r}
# sfc GEOMETRY
st_sfc(point1, multilinestring1)
```

<!-- if you want to use it - st_cast() to a proper geometry type -->
<!-- or st_is to select only one geometry type -->
<!-- http://r-spatial.org/r/2017/01/12/newssf.html -->
<!-- methods(class = "sfc") -->

The simple feature collection objects could have more information about spatial data than just geometries.
It is possible to store coordinate reference systems (CRS) in them.
<!-- What's CRS -->
CRS can be represented by `epsg (SRID)` and `proj4string` attributes.
The default value of `epsg (SRID)` and `proj4string` is `NA` (*Not Available*), which is used when the CRS is unknown:

```{r}
st_sfc(point1, point2)
```

The `sfc` object could have `NA` values in both attributes or have an actual value for one or two CRS attributes.
Importantly, all geometries in the `sfc` objects must have the same CRS. 

We can add coordinate reference system as a `crs` argument of `st_sfc()`. 
This argument could accept either an integer with the `epsg` code or character with `proj4string`.

For example, we can set the WGS 84 using either its epsg code (`4326`) or its `proj4string` definition (`"+proj=longlat +datum=WGS84 +no_defs"`):

```{r}
# EPSG definition
st_sfc(point1, point2, crs = 4326)
```

```{r}
# PROJ4STRING definition
st_sfc(point1, point2, crs = "+proj=longlat +datum=WGS84 +no_defs")
```

Both of these approaches have advantages and disadvantages. 
An `epsg` code is usually shorter and therefore easier to remember. 
The code also refers to only one, well-defined coordinate reference system. 
It could be, however, considered a limitation of `epsg`, as it is not flexible.
On the hand, a `proj4string` definition is longer - it could specify many different parameters, such as projection type, datum and ellipsoid. 
This makes `proj4string` more complicated, but also allows to create many different projections and modify existing ones.
`proj4string` is also supported by the PROJ.4 software (and therefore by the `sf` package), which enables transformations between different projections.

`epsg` always points to a particular CRS.
This property makes possible for PROJ.4 to convert `epsg` into corresponding `proj4string`.
For example, we can set the UTM Zone 11N projection with `epsg` code `2955`:

```{r}
st_sfc(point1, point2, crs = 2955)
```

As you can see above, the `proj4string` definition was automatically added.
Now we can try to set the CRS using `proj4string`:

```{r}
st_sfc(point1, point2, crs = "+proj=utm +zone=11 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs")
```

The above result doesn't contain `epsg`. 
This is due the fact that no general method for conversion from `proj4string` to `epsg` exists.

<!-- precision -->
<!-- plots can be made -->

#### Simple feature objects {#sf}

Most of the time, geometries are related to a set of attributes. 
These attributes could represent the name of the geometry, measured value, group to which the geometry belongs, and many more.
For example, we measured a temperature of 25°C on the Trafalgar Square in London on June 21^th^ 2017. 
This can be described not only by its coordinates and temperature value, but also by the name of the point, the date of the measurement, it's category (city or village), or if the measurement was made using an automatic station.

The simple feature class, `sf`, is a combination of an attribute table (`data.frame`) and simple feature geometry collection (`sfc`).
Simple features are created using the `st_sf()` function:

```{r}
# sfg objects
london_point = st_point(c(0.1, 51.5))
ruan_point = st_point(c(-9, 53))

# sfc object
our_geometry = st_sfc(london_point, ruan_point, crs = 4326)

# data.frame object
our_attributes = data.frame(name = c("London", "Ruan"),
                            temperature = c(25, 13),
                            date = c(as.Date("2017-06-21"), as.Date("2017-06-22")),
                            category = c("city", "village"),
                            automatic = c(FALSE, TRUE))

# sf object
sf_points = st_sf(our_attributes, geometry = our_geometry)
```

The above example illustrates the components of `sf` objects. 
Firstly, simple feature geometry (`sfg`) objects are defined using coordinates.
These objects are combined into a simple feature collection (`sfc`).
The `sfc` also stores the information about coordinate reference system.
`data.frame` is created, where each row corresponds to one geometry feature.
Finally, the attribute table and `sfc` object are tied together using the `st_sf()` function.

```{r}
sf_points
```

The resulting object has two classes - `sf` and `data.frame`:

```{r}
class(sf_points)
```

The result shows that `sf` objects actually have two classes, `sf` and `data.frame`.
Simple features are simply data frames (square tables), but with spatial attributes (usually stored in a special `geom` list-column in the data frame).
This duality is central to the concept of simple features:
most of the time a `sf` can be treated as and behaves like a `data.frame`.
Simple features are, in essence, data frames with a spatial extension.

<!-- methods -->
<!-- methods(class = "sf") -->
<!-- plots -->
<!-- https://r-spatial.github.io/sf/articles/sf1.html#how-attributes-relate-to-geometries -->

## Raster data

<!-- what is raster ?? -->

### An introduction to raster

Raster objects in R are supported by the `raster` package. 
It provides an extensive set of functions to create, read, processed and write of raster datasets.
Beside the general raster data manipulation, `raster` provides many low level functions that can be used to create and develop new concepts. `raster` also supports work on large raster datasets that are stored on a hard drive, but are too large to fit into memory. 
Instead of recreating the whole file in RAM, this package extracts information about the structure of the dataset, such as a number of rows and columns, spatial extent and the name of the file.
When manipulating this dataset, values are read and processed in a small chunk and written either to a specified file on a disk or temporary file.

The `raster` package provides three main classes of objects - `RasterLayer`, `RasterBrick` and `RasterStack`. 
We would refer to all of them as `Raster*`.

<!-- we should replace it with our own dataset -->
<!-- example dataset from spData -->
```{r}
library(raster)
raster_filepath = system.file("external/test.grd", package="raster")
new_raster = raster(raster_filepath)
```

The `Raster*` objects store three types of information: spatial, non-spatial and metadata.
All of them could be shown by just typing the name of the object: 

```{r}
new_raster
```

Spatial properties are expressed as the dimensions (number of rows, number of columns, number of cells), extent and coordinate reference system of the data.

```{r}
# the dimensions (number of rows, number of columns, number of cells)
dim(new_raster)
```

```{r}
# the spatial extent
extent(new_raster)
```

```{r}
# the coordinate reference system
crs(new_raster)
```

Unlike the `sf` package, `raster` only use `proj4string` representation of the coordinate reference system.

Values of the cells are the only non-spatial information in the `Raster*` object.
They could be summarized and plotted using the base R functions, such as `summary()` and `hist()`.

```{r}
# the numerical summary of the data
summary(new_raster)
```

```{r}
# the histogram of the values
hist(new_raster)
```

`getValues()` can be used to extract the values as a numerical vector.

```{r}
new_raster_values = getValues(new_raster)
head(new_raster_values)
```

The `names` function will report the names of layer in the `Raster*` object.

```{r}
names(new_raster)
```

The full list of the `raster` function could be found using `help(package = "raster", topic = "raster-package")`.

### Basic map making

```{r}
plot(new_raster)
```

<!-- examples of using plot() and maybe image()? -->
<!-- more advanced options - rasterVis, tmap, mapview, leaflet -->

### Raster classes

`RasterLayer` represents the simplest raster object, consisting of only one layer and store information about a number of rows and columns, spatial object extent and coordinate reference system used. 
<!-- CRS as proj4 -->
This raster class could store raster values in a RAM memory or only point to a file on hard drive that holds the values.

Object of the `RasterLayer` class is created by the `raster()` function:
<!-- explanation that this function can do many more things -->
<!-- how to add crs -->
<!-- how to add values -->

```{r}
library(raster)
r = raster() # creation of an empty RasterLayer object
r
```

```{r}
# creation of the RasterLayer object with a given number of columns and rows, and extent
r1 = raster(ncol = 101, nrow = 77, xmn = 0, xmx = 101, ymn = 0, ymx = 77)
r1
values(r1) = sample(1:ncell(r1)) # adding random values to the new raster object
```

Two additional classes, `RasterBrick` and `RasterStack` are used when dealing with multiple layers.
These two classes differ in terms of a number of supported files, type of representation and processing speed.

A `RasterBrick` contain multiple layers of raster data, which refer to only a single, mutlilayer file.
<!-- ... -->
<!-- (such as mulitspectral satellite images). -->

`RasterBrick` objects are created using the `brick()` function. 
This function usually takes a filename to a multilayer raster file.
However, it is also possible to provide a `Raster*` object, `array`, and a few more.
All of possible formats could be found on the help file - `?brick`.
<!-- should we use this example or have our own multilayer dataset? -->
```{r}
multilayer_raster_filepath = system.file("external/rlogo.grd", package="raster")
r_brick = brick(multilayer_raster_filepath)
r_brick
```

The `nlayers` function helps to get the number of layers in a `Raster*` object:

```{r}
nlayers(r_brick)
```

A `RasterStack` is a list of `RasterLayer` objects with the same extent and resolution. 
It can be created based on a group of object from many sources - different files, another bands in a multi-band file and `RasterLayer` objects created in R. 

```{r}
raster_on_disk = raster(multilayer_raster_filepath, layer = 1)
raster_in_memory = raster(xmn = 0, xmx = 101, ymn = 0, ymx = 77, res = 1)
values(raster_in_memory) = sample(1:ncell(raster_in_memory))
crs(raster_in_memory) = crs(raster_on_disk)
```

```{r}
r_stack <- stack(raster_in_memory, raster_on_disk)
r_stack
```

Due to its properties, `RasterBrick` objects should be processed in a shorter time than `RasterStack`.
Additionally, operations on `RasterBrick` and `RasterStack` objects will typically return `RasterBrick`.
On the other hand, `RasterStack` give more flexibility, as a single object could be related to data stored in a memory and on disk in the same time.
`RasterBrick` objects could be stored only in a memory or on disk.

## Coordinate Reference Systems

This section is work in progress.

Despite the differences between vector and raster spatial data types, they are united by shared concepts intrinsic to spatial data. Perhaps the most important of these is Coordinate Reference System (CRS), which defines how the spatial elements of the data relate to the surface of the Earth (or other body).

In **sf** the CRS of an object can be retrieved and set using `st_crs()` and `st_set_crs()` respectively:

```{r}
old_crs = st_crs(sf_points) # get CRS
old_crs # print CRS
sf_points = st_set_crs(sf_points, 27700) # set CRS
```

Note the warning emitted after the CRS for `sf_points` was set to `27700`.
This is a good thing: we have imposed a spatial reference onto data without knowing what that means.
To discover what the 'magic number' `27700` means, we can retrieve the CRS again (see Chapter \@ref(coord) for more on CRSs):

```{r}
st_crs(sf_points)
```

## Units

<!-- https://cran.r-project.org/web/packages/units/vignettes/measurement_units_in_R.html -->
The final thing to say about `sf` objects in this chapter is that they have units.
This is advantageous because it prevents confusion caused by the fact that different CRSs use different units (most use meters, some use feet).
Furthermore, it also provides information on dimensionality, as illustrated by calculating the area of Nigeria:

```{r}
nigeria = world[world$name_long == "Nigeria", ]
```

```{r}
st_area(nigeria)
```

The result, as expected, is in units of square meters (m^2^), representing 2 dimensional space, and that Nigeria is a large country!
To translate the huge number into a more digestible size, it is tempting to divide the results by a million (the number of square meters in a square kilometer):

```{r}
st_area(nigeria) / 1e6
```

However, the result is incorrectly given in the same units.
The solution is to set the units with the **units** package:

```{r}
units::set_units(st_area(nigeria), km^2)
```

<!-- Something about when units are not set: -->
<!-- ```{r} -->
<!-- st_distance(sf_point1, sf_point2) -->
<!-- ``` -->

<!-- ## Precision -->

## Exercises

1. What does the summary of the `geometry` column tell us about the `world` dataset, in terms of:

- The geometry type?
- How many countries there are?
- The coordinate reference system (CRS)?

2. Using **sf**'s `plot()` command, create a map of Nigeria in context, building on the code that creates and plots Asia above (see Figure \@ref(fig:nigeria) for an example of what this could look like). 

- Hint: this used the `lwd`, `main` and `col` arguments of `plot()`. 
- Bonus: make the country boundaries a dotted grey line.
- Hint: `border` is an additional argument of `plot()` for **sf** objects.

3. Exercise 3 <!--missing title-->

- What does the `lwd` argument do in the `plot()` code that generates Figure \@ref(fig:africa). 
- Perform the same operations and map making for another continent of your choice.
- Bonus: Download some global geographic data and add attribute variables assigning them to the continents of the world.
