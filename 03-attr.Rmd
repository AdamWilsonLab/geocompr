# Working with attribute data {#attr}

## Prerequisites {-}

- This chapter requires **dplyr**, **sf** and **spData** packages:

```{r, message=FALSE}
library(sf)
library(tidyverse)
```

- You must have loaded the `world` data from the spData package:

```{r, results='hide'}
f = system.file("shapes/wrld.shp", package = "spData")
world = st_read(f)
```

## Introduction

Attribute data is non-geographical information associated with geographical data.
Simple features defined by the **sf** package make working with attribute data easy because objects of class `sf` are data frames.
This means that all the accumulated wisdom and functions accumulated in the R community for handling data frames can be applied to the non-geographic aspects of data.
This is illustrated below for the `world` object representing the countries of the world:

```{r}
class(world)
```

This 'world' dataset contains 63 non-geographical variables (and one geometry column) with data for almost 200 countries, as can be ascertained using base functions for working with tabular data:

```{r}
dim(world) # it is a 2 dimensional object, with rows and columns
nrow(world) # how many rows?
ncol(world) # how many columns?
```

Extracting the attribute data of an `sf` object is the same as removing the geometry column:

```{r}
world_df = world
st_geometry(world_df) = NULL
class(world_df)
```

This can be useful if the geometry column causes problem, e.g. by occupying large amounts of RAM.
However, for most cases there is no harm in keeping the geometry column, as data frame operations on `sf` will only act on the attribute data.
For this reason, being good at working with attribute data in geographical data is the same being proficient at handling data frames in R.
For many applications, the most effective and intuitive way to work with data frames is with the **dplyr** package.
The subsequent examples briefly demonstrate how attribute data in `sf` objects can be manipulated using R's base `data.frame` handling function before moving on to the more expressive **dplyr** approach.

## Handling attribute data with base R

`sf` objects behave exactly the same as `data.frame` objects for most base R operations, including subsetting rows and columns, creating new variables and modelling, as illustrated in the code examples below (results not shown).

```{r, eval=FALSE}
world[1:6, ] # subset rows
```

```{r, eval=FALSE}
world[, 1:3] # subset columns
```

Note that after each operation, the geometry column is preserved.

## Handling attribute data with dplyr

**dplyr** makes working with data frames easier and is compatible with `sf` objects, after the package has been loaded:

```{r, message=FALSE}
library(dplyr)
```

`dplyr` is a powerful package and sub-language of R in its own right, worthy of study in its own right.
The `select()` function, for example, can be used to both subset and renames columns in a single line, for example:

```{r}
world_orig = world # create copy of world dataset for future reference
world = select(world_orig, name_long, continent, population = pop)
head(world, n = 2)
```

This is more concises than the base R equivalent (which saves the result as an object called `world2` to avoid overiding the `world` dataset created previously):

```{r, eval=FALSE}
world2 = world_orig[c("name_long", "continent", "pop")] # subset columns by name
names(world2)[3] = "population" # rename column manually
```

The *pipe* operator (` %>% `), which passes the output of one function into the first argument of the next function, is commonly used in **dplyr** data analysis workflows.
This works because the fundamental **dplyr** functions (or 'verbs', like `select()`) all take a data frame object in and spit a data frame object out.
Combining many functions together with pipes is called *chaining* or *piping*.
The advantage over base R for complex data processing operations is that this approach prevents nested functions and is easy to read because there is a clear order and modularity to the work (a piped command can be commented out, for example).

The example below shows yet another way of creating the renamed `world` dataset, using the pipe operator:

```{r}
world3 = world_orig %>%
        select(name_long, continent)
```

The pipe operator can be used for many data processing tasks with attribute data:

```{r}
# ==, !=, >, >=, <, <=, &, |

# subsetting simple feature rows by values
world_few_rows = world[world$population > 1e9,]

#OR
world_few_rows = world %>% 
        filter(population > 1e9)

head(world_few_rows)
```

<!-- ```{r} -->
<!-- # # add a new column -->
<!-- # world$area = set_units(st_area(world), value = km^2) -->
<!-- # world$pop_density = world$population / world$area -->
<!-- #  -->
<!-- # # OR -->
<!-- # world = world %>% -->
<!-- #         mutate(area = set_units(st_area(.), value = km^2)) %>% -->
<!-- #         mutate(pop_density = population / area) -->
<!-- ``` -->

<!-- Note that this has created a attributes for the area and population density variables: -->

<!-- ```{r} -->
<!-- attributes(world$area) -->
<!-- attributes(world$pop_density) -->
<!-- ``` -->

<!-- These can be set to `NULL` as follows: -->

<!-- ```{r} -->
<!-- attributes(world$area) = NULL -->
<!-- attributes(world$pop_density) = NULL -->
<!-- ``` -->



```{r, results='hide'}
# data summary (not shown)
summary(world)

# data summary by groups (not shown)
world_continents = world %>% 
        group_by(continent) %>% 
        summarise(continent_pop = sum(population), country_n = n())
world_continents
```

```{r}
# sort variables
## by name
world_continents %>% 
        arrange(continent)
## by population (in descending order)
world_continents %>% 
        arrange(-continent_pop)
```

Most of the function from **sf** package do not drop a `geometry` column. To extract a data frame `st_geometry()` or `st_set_geometry()` function can be used.

```{r}
world_st = world
st_geometry(world_st) = NULL
class(world_st)

# OR

world_st2 = world
world_st2 = world_st2 %>% st_set_geometry(NULL)
class(world_st2)
```


<!-- 
- dplyr, tidyr, and purrr packages
- lubridate??
- pipes
-->

<!-- 
- view, add new rows/columns, subset, select, summarize 
-->
