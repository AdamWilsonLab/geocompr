# CLI/GUI integration

An important feature of R is it's command-line interface (CLI). To be more specific, R has been designed from the beginning as an interface to other languages [@Chambers.2016]. By contrast, R has never been intended to be a GIS. This in mind, it is really astonishing how much geofunctionality R is providing today. Nevertheless, many, if not most geoalgorithms (despite rgdal, rgeos, sf, sp, etc.) are missing in R. Even worse, R's memory management almost inhibits the complex processing of big spatial data. Of course, it might be possible to overcome these shortcomings by writing new geo-related R packages which in turn are using C++ power in the background (cite Rcpp). However, that would only duplicate already available and already tested functionality, namely GIS functionality (most of which is written in C++ by the way). Hence, instead of duplicating, we merely need to create an interface to already existing software. This chapter will outline how you can access QGIS (**RQGIS**), SAGA (**RSAGA**) and GRASS (**rgrass7**) from within R, alongside good knowledge of the strengths and weaknesses of 'CLIs vs GUIs'.
<!-- sounds like you would like to focus on open-source GIS? There is also the RPyGeo-package integrating R with ArcGIS. Admittedly, it needs some polishing (a student of ours will take care of this) but maybe we can at least mention it -->
<!-- Sound like a good list of contents? -->
As mentioned in chapter \@ref(intro), doing GIS at the command-line makes it more reproducible, in-line with the principles of Geographic Data Science.
However, there are times when a graphical user interface (GUI) is useful.

This chapter outlines ways to facilitate integration between the approaches.
The 'CLI vs GUI' debate is often framed in adverserial terms but it does not have to be.
As outlined by Gary Sherman (who should be well-qualified to comment on the debate as he created the world's premier open source GUI-based GIS!), there are times when one can be better than the other:

> With the advent of 'modern' GIS software, most people want to point and
click their way through life. Thatâ€™s good, but there is a tremendous amount
of flexibility and power waiting for you with the command line. Many times
you can do something on the command line in a fraction of the time you
can do it with a GUI.

- that's right; even more important you can easily automate repetitive tasks
- and it is much more reproducible (what science ought to be). Think also of your future you, in a couple of months from now you really have no idea any longer how exactly you have done complex geoprocessing consisting of several steps.
- if you are missing a spatial function just write it yourself

But there are times when it's useful to 'point and click'.

<!-- Idea: bullet points of times when GUI-based systems (particularly QGIS) are advantageous.
- digitizing (though there is a new package mapedit from Tim Appelhans that allows for some interactive digitizing in R)
- georeferencing
- stereoscopic mapping (think of LiDAR and structure from motion stuff)
- map production (in case you only want to create a beautiful map once. If you have to produce it over and over again, then maybe CLI is the better approach)
- zooming and dragging on WMS (though this is also possible with mapview and leaflet)
- -->

## (R)QGIS
QGIS provides a Python API that allows the user to run QGIS functionality outside of its GUI. **RQGIS** establishes a tunnel to this Python API through the **reticulate** (cite reticulate) package. Basically, functions `set_env` and `open_app` are doing this. Note that it is optional to run `set_env` and `open_app` since all functions depending on their output will run them automatically if needed. Before running **RQGIS** you have to make sure to have installed QGIS and all its (third-party) dependencies such as SAGA and GRASS. To help you with the installation process, please follow the steps as detailled in `vignette("install_guide", package = "RQGIS")` for several platforms (Windows, Linux, MacOS).

```{r qgis_setup}
library("RQGIS")
set_env()
open_app()
```

Leaving the `path`-argument of `set_env` unspecified will search the computer for a QGIS installation. Hence, it is faster to specify explicitly the path to your QGIS installation. Subsequently, `open_app` sets all paths necessary to run QGIS from within R, and finally creates a so-called QGIS custom application [http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/intro.html#using-pyqgis-in-custom-applications](http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/intro.html#using-pyqgis-in-custom-applications). We are now ready for some QGIS geoprocessing from within R! First of all, we load some data from **spData**-package, namely the boroughs of London (`lnd`) and cycle hire points in London (`cycle_hire`).

```{r}
library("spData")
data("cycle_hire")
data("lnd")
```
<!-- silly example, other suggestions welcome also with regard to RSAGA and rgrass7-->
In chapter 2 (reference it), we already learned how to do a spatial overlay using the **sf**-package. Of course, any GIS is also able to perform spatial overlays. Here, we would like to know how many cycle points we can find per borough. First of all, we need to come up with the name of the function in QGIS. `find_algorithms` lets you search all QGIS geoalgorithms. Here, we assume that the short description of the function contains first the word "point" and secondly somewhere later also the word "poly". If you have no clue at all what to look for you can leave the `search_term`-argument empty which will return a list of all available geoalgorithms.

```{r}
find_algorithms("points.*poly")
```

Now that we know the name of the function ("qgis:countpointsinpolygon"), we wonder how we can use it. `get_usage` returns all function parameters and default values. `open_help` lets you access the corresponding online help.

```{r}
alg <- "qgis:countpointsinpolygon"
get_usage(alg)
```

```{r, eval = FALSE}
open_help(alg)
```

Finally, we can let QGIS do the work. Note that the workhorse function `run_qgis` accepts R named arguments, i.e., you can specify the parameter names as returned by `get_usage` as you would do in any other R function. Note also that `run_qgis` accepts spatial objects residing in R's global environment as input (here: `lnd` and `cycle_hire`). But of course, you could also specify paths to shapefiles stored on disk. Setting the `load_output` to `TRUE` automatically loads the QGIS output into R. Since we only indicated the name of the output ("cycle.shp"), `run_qgis` saves the output to a temporary folder as returned by `tempdir()`, and loads it into R as an **sf**-object.

```{r}
bike_points <- run_qgis(alg, POLYGONS = lnd, POINTS = cycle_hire, FIELD = "no_bikes", 
                        OUTPUT = "cycle.shp", load_output = TRUE)
summary(bike_points$no_bikes)
sum(bike_points$no_bikes > 0)
```


## (R)SAGA
"SAGA CMD is a command line interface to execute SAGA modules. Other than SAGA GUI, it provides no functionality for data management and data visualization. It's purpose is to automate tasks by writing scripts or to execute SAGA modules from within an other application like a web server. This section will describe the necessary setup of your system to use SAGA CMD and execute modules" [https://sourceforge.net/p/saga-gis/wiki/Executing%20Modules%20with%20SAGA%20CMD/](https://sourceforge.net/p/saga-gis/wiki/Executing%20Modules%20with%20SAGA%20CMD/).

hint to vignette("RSAGA-landslides", package = "RSAGA").


## GRASS through **rgrass7**

use **link2GI** for an easy set-up of the GRASS environment (though it is beneficial to GRASS users to have a working knowledge of how GRASS works internally)

## When to use what?