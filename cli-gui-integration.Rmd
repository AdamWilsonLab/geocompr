# CLI/GUI integration

An important feature of R is it's command-line interface (CLI). To be more specific, R has been designed from the beginning as an interface to other languages [@Chambers.2016]. By contrast, R has never been intended to be a GIS. This in mind, it is really astonishing how much geofunctionality R is providing today. Nevertheless, many, if not most geoalgorithms (despite rgdal, rgeos, sf, sp, etc.) are missing in R. Even worse, R's memory management almost inhibits the complex processing of big spatial data. Of course, it might be possible to overcome these shortcomings by writing new geo-related R packages which in turn are using C++ power in the background (cite Rcpp). However, that would only duplicate already available and already tested functionality, namely GIS functionality (most of which is written in C++ by the way). Hence, instead of duplicating, we merely need to create an interface to already existing software. This chapter will outline how you can access QGIS (**RQGIS**), SAGA (**RSAGA**) and GRASS (**rgrass7**) from within R, alongside good knowledge of the strengths and weaknesses of 'CLIs vs GUIs'.
<!-- sounds like you would like to focus on open-source GIS? There is also the RPyGeo-package integrating R with ArcGIS. Admittedly, it needs some polishing (a student of ours will take care of this) but maybe we can at least mention it -->
<!-- Sound like a good list of contents? -->
As mentioned in chapter \@ref(intro), doing GIS at the command-line makes it more reproducible, in-line with the principles of Geographic Data Science.
However, there are times when a graphical user interface (GUI) is useful.

This chapter outlines ways to facilitate integration between the approaches.
The 'CLI vs GUI' debate is often framed in adverserial terms but it does not have to be.
As outlined by Gary Sherman (who should be well-qualified to comment on the debate as he created the world's premier open source GUI-based GIS!), there are times when one can be better than the other:

> With the advent of 'modern' GIS software, most people want to point and
click their way through life. Thatâ€™s good, but there is a tremendous amount
of flexibility and power waiting for you with the command line. Many times
you can do something on the command line in a fraction of the time you
can do it with a GUI.

- that's right; even more important you can easily automate repetitive tasks
- and it is much more reproducible (what science ought to be). Think also of your future you, in a couple of months from now you really have no idea any longer how exactly you have done complex geoprocessing consisting of several steps.
- if you are missing a spatial function just write it yourself

But there are times when it's useful to 'point and click'.

<!-- Idea: bullet points of times when GUI-based systems (particularly QGIS) are advantageous.
- digitizing (though there is a new package mapedit from Tim Appelhans that allows for some interactive digitizing in R)
- georeferencing
- stereoscopic mapping (think of LiDAR and structure from motion stuff)
- map production (in case you only want to create a beautiful map once. If you have to produce it over and over again, then maybe CLI is the better approach)
- zooming and dragging on WMS (though this is also possible with mapview and leaflet)
- -->

## (R)QGIS
The main advantage of using QGIS is that it provides a unified interface to many open-source GIS. First and foremost this means that you have access to GDAL/OGR, GRASS and SAGA through QGIS but also to other third-party providers such as TauDEM, Orfeo Toolbox and Lastools (tools for LiDAR data) [@Graser.2015]. To run all these geoalgorithms (frequently more than 1000 depending on your set up) outside of the QGIS GUI, 
QGIS provides a Python API. **RQGIS** establishes a tunnel to this Python API through the **reticulate** (cite reticulate) package. Basically, functions `set_env` and `open_app` are doing this. Note that it is optional to run `set_env` and `open_app` since all functions depending on their output will run them automatically if needed. Before running **RQGIS** you have to make sure to have installed QGIS and all its (third-party) dependencies such as SAGA and GRASS. To help you with the installation process, please follow the steps as detailled in `vignette("install_guide", package = "RQGIS")` for several platforms (Windows, Linux, MacOS).

```{r qgis_setup}
library("RQGIS")
set_env()
open_app()
```

Leaving the `path`-argument of `set_env` unspecified will search the computer for a QGIS installation. Hence, it is faster to specify explicitly the path to your QGIS installation. Subsequently, `open_app` sets all paths necessary to run QGIS from within R, and finally creates a so-called QGIS custom application [http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/intro.html#using-pyqgis-in-custom-applications](http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/intro.html#using-pyqgis-in-custom-applications). We are now ready for some QGIS geoprocessing from within R! First of all, we load some data from the **spData**-package, namely the boroughs of London (`lnd`) and cycle hire points in London (`cycle_hire`).

```{r}
library("spData")
data("cycle_hire")
data("lnd")
```
<!-- silly example, other suggestions welcome also with regard to RSAGA and rgrass7-->
In chapter 2 (reference it), we already learned how to do a spatial overlay using the **sf**-package. Of course, any GIS is also able to perform spatial overlays. Here, we would like to know how many cycle points we can find per borough. First of all, we need to come up with the name of the function in QGIS. `find_algorithms` lets you search all QGIS geoalgorithms with the help of regular expressions. Here, we assume that the short description of the function contains first the word "point" and secondly somewhere later also the word "poly". If you have no clue at all what to look for you can leave the `search_term`-argument empty which will return a list of all available QGIS geoalgorithms. If you also want to have a short description for each geoalgorithm, set the `name_only`-parameter to FALSE.

```{r}
find_algorithms("points.*poly", name_only = TRUE)
```

Now that we know the name of the function ("qgis:countpointsinpolygon"), we wonder how we can use it. `get_usage` returns all function parameters and default values. `open_help` lets you access the corresponding online help.

```{r}
alg <- "qgis:countpointsinpolygon"
get_usage(alg)
```

```{r, eval = FALSE}
open_help(alg)
```

Finally, we can let QGIS do the work. Note that the workhorse function `run_qgis` accepts R named arguments, i.e., you can specify the parameter names as returned by `get_usage` as you would do in any other R function. Note also that `run_qgis` accepts spatial objects residing in R's global environment as input (here: `lnd` and `cycle_hire`). But of course, you could also specify paths to shapefiles stored on disk. Setting the `load_output` to `TRUE` automatically loads the QGIS output into R. Since we only indicated the name of the output ("cycle.shp"), `run_qgis` saves the output to a temporary folder as returned by `tempdir()`, and loads it into R as an **sf**-object.

```{r}
bike_points <- run_qgis(alg, POLYGONS = lnd, POINTS = cycle_hire, FIELD = "no_bikes", 
                        OUTPUT = "cycle.shp", load_output = TRUE)
summary(bike_points$no_bikes)
sum(bike_points$no_bikes > 0)
```

In case you leave some parameters of a geoalgorithm unspecified, `run_qgis` will automatically use the default values as arguments if available. To find out about the default values, run `get_args_man`.  

```{r}
get_args_man(alg)
```

In this case the output tells us, had we left the `FIELDS`-parameter unspecified, our output (attribute) field would have been named "NUMPOINTS" (instead of "no_bikes").

<!--
"grass7:v.vect.stats" would achieve the same but is unavailable in QGIS
-->

Other notes:
- leaving the output parameter(s) unspecified, saves the resulting QGIS output to a temporary folder created by QGIS. `run_qgis` prints these paths to the console after sucessfully runing the QGIS engine.
- If the output consists of multiple files and you have set `load_output` to `TRUE`, `run_qgis` will return a list with each element corresponding to one output file.

To learn more about **RQGIS** please refer to the (hopefully) forthcoming paper (cite). 

## (R)SAGA
"SAGA CMD is a command line interface to execute SAGA modules. Other than SAGA GUI, it provides no functionality for data management and data visualization. It's purpose is to automate tasks by writing scripts or to execute SAGA modules from within an other application like a web server. This section will describe the necessary setup of your system to use SAGA CMD and execute modules" [https://sourceforge.net/p/saga-gis/wiki/Executing%20Modules%20with%20SAGA%20CMD/](https://sourceforge.net/p/saga-gis/wiki/Executing%20Modules%20with%20SAGA%20CMD/).

hint to vignette("RSAGA-landslides", package = "RSAGA").

Though SAGA is a hybrid GIS, its main focus has been from the beginning on raster processing (and specifically on hydrological/climatolgical/geomorphometric raster processing -> look it up). Hence, SAGA is especially good at the processing of large rasters data sets. Overall, there are more than 600 geoalgorithms available [@Conrad.2015].  

cite citation("RSAGA").

## GRASS through **rgrass7**

use **link2GI** for an easy set-up of the GRASS environment (though it is beneficial to GRASS users to have a working knowledge of how GRASS works internally)

GRASS more than 500 functions (\url{http://grass.osgeo.org/grass72/manuals/})

## When to use what?

@article{Conrad.2015,
 author = {O. Conrad and Benjamin Bechtel and M. Bock and H. Dietrich and E. Fischer and Lars Gerlitz and J. Wehberg and V. Wichmann and J{\"u}rgen B{\"o}hner},
 year = {2015},
 title = {System for Automated Geoscientific Analyses (SAGA) v. 2.1.4},
 pages = {1991--2007},
 volume = {8},
 number = {7},
 issn = {1991-959X},
 journal = {Geoscientific Model Development}
}

 @article{Graser.2015,
 author = {Anita Graser and Victor Olaya},
 year = {2015},
 title = {Processing: A Python Framework for the Seamless Integration of Geoprocessing Tools in QGIS},
 url = {http://www.mdpi.com/2220-9964/4/4/2219/pdf},
 pages = {2219--2245},
 volume = {4},
 number = {4},
 journal = {ISPRS International Journal of Geo-Information},
 doi = {10.3390/ijgi4042219}
}

@book{Neteler.2008,
 author = {Markus Neteler and Helena Mitasova},
 year = {2008},
 title = {Open Source GIS: A GRASS GIS Approach},
 address = {New York},
 publisher = {Springer-Verlag}
}
